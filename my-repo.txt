This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
  dependabot.yml
.kamal/
  hooks/
    docker-setup.sample
    post-app-boot.sample
    post-deploy.sample
    post-proxy-reboot.sample
    pre-app-boot.sample
    pre-build.sample
    pre-connect.sample
    pre-deploy.sample
    pre-proxy-reboot.sample
  secrets
app/
  controllers/
    concerns/
      .keep
    application_controller.rb
    graphql_controller.rb
  graphql/
    mutations/
      .keep
      base_mutation.rb
      create_appointment.rb
      optimize_routes.rb
    resolvers/
      base_resolver.rb
    types/
      .keep
      account_type.rb
      appointment_type.rb
      base_argument.rb
      base_connection.rb
      base_edge.rb
      base_enum.rb
      base_field.rb
      base_input_object.rb
      base_interface.rb
      base_object.rb
      base_scalar.rb
      base_union.rb
      customer_type.rb
      mutation_type.rb
      node_type.rb
      optimization_job_type.rb
      optimization_savings_type.rb
      query_type.rb
      route_stop_type.rb
      route_type.rb
      service_type.rb
      staff_type.rb
      vertical_type.rb
    carestack_schema.rb
  jobs/
    application_job.rb
  mailers/
    application_mailer.rb
  models/
    concerns/
      .keep
    account.rb
    application_record.rb
    appointment.rb
    customer.rb
    optimization_job.rb
    route_stop.rb
    route.rb
    service_type.rb
    staff.rb
    travel_segment.rb
    vertical.rb
  services/
    genetic_vrp_solver.rb
    google_maps_service.rb
    mock_google_map_service.rb
    mock_google_maps_service.rb
    route_optimzer_service.rb
    simple_route_optimizer_service.rb
  views/
    layouts/
      mailer.html.erb
      mailer.text.erb
bin/
  brakeman
  bundle
  dev
  docker-entrypoint
  jobs
  kamal
  rails
  rake
  rubocop
  setup
  thrust
config/
  environments/
    development.rb
    production.rb
    test.rb
  initializers/
    cors.rb
    filter_parameter_logging.rb
    inflections.rb
  locales/
    en.yml
  application.rb
  boot.rb
  cable.yml
  cache.yml
  credentials.yml.enc
  database.yml
  deploy.yml
  environment.rb
  puma.rb
  queue.yml
  recurring.yml
  routes.rb
  storage.yml
db/
  migrate/
    20250831202143_create_verticals.rb
    20250831202159_create_accounts.rb
    20250831202216_create_service_types.rb
    20250831202229_create_customers.rb
    20250831202241_create_staffs.rb
    20250831202253_create_appointments.rb
    20250831213446_create_flipper_tables.rb
    20250904185504_create_routes.rb
    20250904185532_create_route_stops.rb
    20250904185544_create_travel_segments.rb
    20250904185606_create_optimization_jobs.rb
    20250904185634_add_location_fields_to_customers.rb
    20250904185646_add_location_fields_to_staff.rb
  cable_schema.rb
  cache_schema.rb
  queue_schema.rb
  schema.rb
  seeds.rb
lib/
  tasks/
    .keep
log/
  .keep
public/
  robots.txt
script/
  .keep
spec/
  factories/
    accounts.rb
    appointments.rb
    customers.rb
    optimization_jobs.rb
    route_stops.rb
    routes.rb
    service_types.rb
    staffs.rb
    travel_segments.rb
    verticals.rb
  models/
    account_spec.rb
    appointment_spec.rb
    customer_spec.rb
    optimization_job_spec.rb
    route_spec.rb
    route_stop_spec.rb
    service_type_spec.rb
    staff_spec.rb
    travel_segment_spec.rb
    vertical_spec.rb
storage/
  .keep
.dockerignore
.gitattributes
.gitignore
.rubocop.yml
.ruby-version
config.ru
Dockerfile
Gemfile
Rakefile
README.md
s: 456 Oak Ave, Senior Community
tomer = Customer.create!(
tomer = Customer.create!(  account: elderly_account,  first_name: "Dorothy",  last_name: "Williams",  email: "dorothy@example.com",  phone: "555-0789",  address: "456 Oak Ave, Senior Community")
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tomer = Customer.create!(  account: elderly_account,  first_name: "Dorothy",  last_name: "Williams",  email: "dorothy@example.com",  phone: "555-0789",  address: "456 Oak Ave, Senior Community")">
=> [[32m#<ServiceType:0x00007f6ba4d66a70[0m
  id: [1;34m5[0m,
  name: [31m[1;31m"[0m[31mCompanion Care[1;31m"[0m[31m[0m,
  vertical_id: [1;34m2[0m,
  duration_minutes: [1;34m240[0m,
  requires_background_check: [1;36mtrue[0m,
  min_staff_ratio: [1;35m0.1e1[0m,
  created_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.159079000 +0000[1;31m"[0m[31m[0m,
  updated_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.159079000 +0000[1;31m"[0m[31m[0m[32m>[0m,
 [32m#<ServiceType:0x00007f6ba5307f88[0m
  id: [1;34m6[0m,
  name: [31m[1;31m"[0m[31mPersonal Care Assistance[1;31m"[0m[31m[0m,
  vertical_id: [1;34m2[0m,
  duration_minutes: [1;34m120[0m,
  requires_background_check: [1;36mtrue[0m,
  min_staff_ratio: [1;35m0.1e1[0m,
  created_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.180891000 +0000[1;31m"[0m[31m[0m,
  updated_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.180891000 +0000[1;31m"[0m[31m[0m[32m>[0m,
 [32m#<ServiceType:0x00007f6ba5307308[0m
  id: [1;34m7[0m,
  name: [31m[1;31m"[0m[31m24-Hour Care[1;31m"[0m[31m[0m,
  vertical_id: [1;34m2[0m,
  duration_minutes: [1;34m1440[0m,
  requires_background_check: [1;36mtrue[0m,
  min_staff_ratio: [1;35m0.2e1[0m,
  created_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.196416000 +0000[1;31m"[0m[31m[0m,
  updated_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.196416000 +0000[1;31m"[0m[31m[0m[32m>[0m,
 [32m#<ServiceType:0x00007f6ba5306408[0m
  id: [1;34m8[0m,
  name: [31m[1;31m"[0m[31mMedical Appointment Transport[1;31m"[0m[31m[0m,
  vertical_id: [1;34m2[0m,
  duration_minutes: [1;34m180[0m,
  requires_background_check: [1;36mtrue[0m,
  min_staff_ratio: [1;35m0.1e1[0m,
  created_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.224360000 +0000[1;31m"[0m[31m[0m,
  updated_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.224360000 +0000[1;31m"[0m[31m[0m[32m>[0m]
</file>

<file path=".github/workflows/ci.yml">
name: CI

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  scan_ruby:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: .ruby-version
          bundler-cache: true

      - name: Scan for common Rails security vulnerabilities using static analysis
        run: bin/brakeman --no-pager

  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: .ruby-version
          bundler-cache: true

      - name: Lint code for consistent style
        run: bin/rubocop -f github
</file>

<file path=".github/dependabot.yml">
version: 2
updates:
- package-ecosystem: bundler
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10
- package-ecosystem: github-actions
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10
</file>

<file path=".kamal/hooks/docker-setup.sample">
#!/bin/sh

echo "Docker set up on $KAMAL_HOSTS..."
</file>

<file path=".kamal/hooks/post-app-boot.sample">
#!/bin/sh

echo "Booted app version $KAMAL_VERSION on $KAMAL_HOSTS..."
</file>

<file path=".kamal/hooks/post-deploy.sample">
#!/bin/sh

# A sample post-deploy hook
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_ROLES (if set)
# KAMAL_DESTINATION (if set)
# KAMAL_RUNTIME

echo "$KAMAL_PERFORMER deployed $KAMAL_VERSION to $KAMAL_DESTINATION in $KAMAL_RUNTIME seconds"
</file>

<file path=".kamal/hooks/post-proxy-reboot.sample">
#!/bin/sh

echo "Rebooted kamal-proxy on $KAMAL_HOSTS"
</file>

<file path=".kamal/hooks/pre-app-boot.sample">
#!/bin/sh

echo "Booting app version $KAMAL_VERSION on $KAMAL_HOSTS..."
</file>

<file path=".kamal/hooks/pre-build.sample">
#!/bin/sh

# A sample pre-build hook
#
# Checks:
# 1. We have a clean checkout
# 2. A remote is configured
# 3. The branch has been pushed to the remote
# 4. The version we are deploying matches the remote
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_ROLES (if set)
# KAMAL_DESTINATION (if set)

if [ -n "$(git status --porcelain)" ]; then
  echo "Git checkout is not clean, aborting..." >&2
  git status --porcelain >&2
  exit 1
fi

first_remote=$(git remote)

if [ -z "$first_remote" ]; then
  echo "No git remote set, aborting..." >&2
  exit 1
fi

current_branch=$(git branch --show-current)

if [ -z "$current_branch" ]; then
  echo "Not on a git branch, aborting..." >&2
  exit 1
fi

remote_head=$(git ls-remote $first_remote --tags $current_branch | cut -f1)

if [ -z "$remote_head" ]; then
  echo "Branch not pushed to remote, aborting..." >&2
  exit 1
fi

if [ "$KAMAL_VERSION" != "$remote_head" ]; then
  echo "Version ($KAMAL_VERSION) does not match remote HEAD ($remote_head), aborting..." >&2
  exit 1
fi

exit 0
</file>

<file path=".kamal/hooks/pre-connect.sample">
#!/usr/bin/env ruby

# A sample pre-connect check
#
# Warms DNS before connecting to hosts in parallel
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_ROLES (if set)
# KAMAL_DESTINATION (if set)
# KAMAL_RUNTIME

hosts = ENV["KAMAL_HOSTS"].split(",")
results = nil
max = 3

elapsed = Benchmark.realtime do
  results = hosts.map do |host|
    Thread.new do
      tries = 1

      begin
        Socket.getaddrinfo(host, 0, Socket::AF_UNSPEC, Socket::SOCK_STREAM, nil, Socket::AI_CANONNAME)
      rescue SocketError
        if tries < max
          puts "Retrying DNS warmup: #{host}"
          tries += 1
          sleep rand
          retry
        else
          puts "DNS warmup failed: #{host}"
          host
        end
      end

      tries
    end
  end.map(&:value)
end

retries = results.sum - hosts.size
nopes = results.count { |r| r == max }

puts "Prewarmed %d DNS lookups in %.2f sec: %d retries, %d failures" % [ hosts.size, elapsed, retries, nopes ]
</file>

<file path=".kamal/hooks/pre-deploy.sample">
#!/usr/bin/env ruby

# A sample pre-deploy hook
#
# Checks the Github status of the build, waiting for a pending build to complete for up to 720 seconds.
#
# Fails unless the combined status is "success"
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_COMMAND
# KAMAL_SUBCOMMAND
# KAMAL_ROLES (if set)
# KAMAL_DESTINATION (if set)

# Only check the build status for production deployments
if ENV["KAMAL_COMMAND"] == "rollback" || ENV["KAMAL_DESTINATION"] != "production"
  exit 0
end

require "bundler/inline"

# true = install gems so this is fast on repeat invocations
gemfile(true, quiet: true) do
  source "https://rubygems.org"

  gem "octokit"
  gem "faraday-retry"
end

MAX_ATTEMPTS = 72
ATTEMPTS_GAP = 10

def exit_with_error(message)
  $stderr.puts message
  exit 1
end

class GithubStatusChecks
  attr_reader :remote_url, :git_sha, :github_client, :combined_status

  def initialize
    @remote_url = github_repo_from_remote_url
    @git_sha = `git rev-parse HEAD`.strip
    @github_client = Octokit::Client.new(access_token: ENV["GITHUB_TOKEN"])
    refresh!
  end

  def refresh!
    @combined_status = github_client.combined_status(remote_url, git_sha)
  end

  def state
    combined_status[:state]
  end

  def first_status_url
    first_status = combined_status[:statuses].find { |status| status[:state] == state }
    first_status && first_status[:target_url]
  end

  def complete_count
    combined_status[:statuses].count { |status| status[:state] != "pending"}
  end

  def total_count
    combined_status[:statuses].count
  end

  def current_status
    if total_count > 0
      "Completed #{complete_count}/#{total_count} checks, see #{first_status_url} ..."
    else
      "Build not started..."
    end
  end

  private
    def github_repo_from_remote_url
      url = `git config --get remote.origin.url`.strip.delete_suffix(".git")
      if url.start_with?("https://github.com/")
        url.delete_prefix("https://github.com/")
      elsif url.start_with?("git@github.com:")
        url.delete_prefix("git@github.com:")
      else
        url
      end
    end
end


$stdout.sync = true

begin
  puts "Checking build status..."

  attempts = 0
  checks = GithubStatusChecks.new

  loop do
    case checks.state
    when "success"
      puts "Checks passed, see #{checks.first_status_url}"
      exit 0
    when "failure"
      exit_with_error "Checks failed, see #{checks.first_status_url}"
    when "pending"
      attempts += 1
    end

    exit_with_error "Checks are still pending, gave up after #{MAX_ATTEMPTS * ATTEMPTS_GAP} seconds" if attempts == MAX_ATTEMPTS

    puts checks.current_status
    sleep(ATTEMPTS_GAP)
    checks.refresh!
  end
rescue Octokit::NotFound
  exit_with_error "Build status could not be found"
end
</file>

<file path=".kamal/hooks/pre-proxy-reboot.sample">
#!/bin/sh

echo "Rebooting kamal-proxy on $KAMAL_HOSTS..."
</file>

<file path=".kamal/secrets">
# Secrets defined here are available for reference under registry/password, env/secret, builder/secrets,
# and accessories/*/env/secret in config/deploy.yml. All secrets should be pulled from either
# password manager, ENV, or a file. DO NOT ENTER RAW CREDENTIALS HERE! This file needs to be safe for git.

# Example of extracting secrets from 1password (or another compatible pw manager)
# SECRETS=$(kamal secrets fetch --adapter 1password --account your-account --from Vault/Item KAMAL_REGISTRY_PASSWORD RAILS_MASTER_KEY)
# KAMAL_REGISTRY_PASSWORD=$(kamal secrets extract KAMAL_REGISTRY_PASSWORD ${SECRETS})
# RAILS_MASTER_KEY=$(kamal secrets extract RAILS_MASTER_KEY ${SECRETS})

# Use a GITHUB_TOKEN if private repositories are needed for the image
# GITHUB_TOKEN=$(gh config get -h github.com oauth_token)

# Grab the registry password from ENV
KAMAL_REGISTRY_PASSWORD=$KAMAL_REGISTRY_PASSWORD

# Improve security by using a password manager. Never check config/master.key into git!
RAILS_MASTER_KEY=$(cat config/master.key)
</file>

<file path="app/controllers/concerns/.keep">

</file>

<file path="app/controllers/application_controller.rb">
class ApplicationController < ActionController::API
end
</file>

<file path="app/graphql/mutations/.keep">

</file>

<file path="app/graphql/resolvers/base_resolver.rb">
# frozen_string_literal: true

module Resolvers
  class BaseResolver < GraphQL::Schema::Resolver
  end
end
</file>

<file path="app/graphql/types/.keep">

</file>

<file path="app/graphql/types/base_argument.rb">
# frozen_string_literal: true

module Types
  class BaseArgument < GraphQL::Schema::Argument
  end
end
</file>

<file path="app/graphql/types/base_connection.rb">
# frozen_string_literal: true

module Types
  class BaseConnection < Types::BaseObject
    # add `nodes` and `pageInfo` fields, as well as `edge_type(...)` and `node_nullable(...)` overrides
    include GraphQL::Types::Relay::ConnectionBehaviors
  end
end
</file>

<file path="app/graphql/types/base_edge.rb">
# frozen_string_literal: true

module Types
  class BaseEdge < Types::BaseObject
    # add `node` and `cursor` fields, as well as `node_type(...)` override
    include GraphQL::Types::Relay::EdgeBehaviors
  end
end
</file>

<file path="app/graphql/types/base_enum.rb">
# frozen_string_literal: true

module Types
  class BaseEnum < GraphQL::Schema::Enum
  end
end
</file>

<file path="app/graphql/types/base_field.rb">
# frozen_string_literal: true

module Types
  class BaseField < GraphQL::Schema::Field
    argument_class Types::BaseArgument
  end
end
</file>

<file path="app/graphql/types/base_input_object.rb">
# frozen_string_literal: true

module Types
  class BaseInputObject < GraphQL::Schema::InputObject
    argument_class Types::BaseArgument
  end
end
</file>

<file path="app/graphql/types/base_interface.rb">
# frozen_string_literal: true

module Types
  module BaseInterface
    include GraphQL::Schema::Interface
    edge_type_class(Types::BaseEdge)
    connection_type_class(Types::BaseConnection)

    field_class Types::BaseField
  end
end
</file>

<file path="app/graphql/types/base_object.rb">
# frozen_string_literal: true

module Types
  class BaseObject < GraphQL::Schema::Object
    edge_type_class(Types::BaseEdge)
    connection_type_class(Types::BaseConnection)
    field_class Types::BaseField
  end
end
</file>

<file path="app/graphql/types/base_scalar.rb">
# frozen_string_literal: true

module Types
  class BaseScalar < GraphQL::Schema::Scalar
  end
end
</file>

<file path="app/graphql/types/base_union.rb">
# frozen_string_literal: true

module Types
  class BaseUnion < GraphQL::Schema::Union
    edge_type_class(Types::BaseEdge)
    connection_type_class(Types::BaseConnection)
  end
end
</file>

<file path="app/graphql/types/node_type.rb">
# frozen_string_literal: true

module Types
  module NodeType
    include Types::BaseInterface
    # Add the `id` field
    include GraphQL::Types::Relay::NodeBehaviors
  end
end
</file>

<file path="app/graphql/carestack_schema.rb">
# frozen_string_literal: true

class CarestackSchema < GraphQL::Schema
  mutation(Types::MutationType)
  query(Types::QueryType)

  # For batch-loading (see https://graphql-ruby.org/dataloader/overview.html)
  use GraphQL::Dataloader

  # GraphQL-Ruby calls this when something goes wrong while running a query:
  def self.type_error(err, context)
    # if err.is_a?(GraphQL::InvalidNullError)
    #   # report to your bug tracker here
    #   return nil
    # end
    super
  end

  # Union and Interface Resolution
  def self.resolve_type(abstract_type, obj, ctx)
    # TODO: Implement this method
    # to return the correct GraphQL object type for `obj`
    raise(GraphQL::RequiredImplementationMissingError)
  end

  # Limit the size of incoming queries:
  max_query_string_tokens(5000)

  # Stop validating when it encounters this many errors:
  validate_max_errors(100)

  # Relay-style Object Identification:

  # Return a string UUID for `object`
  def self.id_from_object(object, type_definition, query_ctx)
    # For example, use Rails' GlobalID library (https://github.com/rails/globalid):
    object.to_gid_param
  end

  # Given a string UUID, find the object
  def self.object_from_id(global_id, query_ctx)
    # For example, use Rails' GlobalID library (https://github.com/rails/globalid):
    GlobalID.find(global_id)
  end
end
</file>

<file path="app/jobs/application_job.rb">
class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  # retry_on ActiveRecord::Deadlocked

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError
end
</file>

<file path="app/mailers/application_mailer.rb">
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end
</file>

<file path="app/models/concerns/.keep">

</file>

<file path="app/models/application_record.rb">
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end
</file>

<file path="app/models/appointment.rb">
class Appointment < ApplicationRecord
  belongs_to :account
  belongs_to :customer
  belongs_to :service_type
  belongs_to :staff
end
</file>

<file path="app/models/travel_segment.rb">
class TravelSegment < ApplicationRecord
  belongs_to :from_appointment
  belongs_to :to_appointment
end
</file>

<file path="app/views/layouts/mailer.html.erb">
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>
</file>

<file path="app/views/layouts/mailer.text.erb">
<%= yield %>
</file>

<file path="bin/brakeman">
#!/usr/bin/env ruby
require "rubygems"
require "bundler/setup"

ARGV.unshift("--ensure-latest")

load Gem.bin_path("brakeman", "brakeman")
</file>

<file path="bin/bundle">
#!/usr/bin/env ruby
# frozen_string_literal: true

#
# This file was generated by Bundler.
#
# The application 'bundle' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require "rubygems"

m = Module.new do
  module_function

  def invoked_as_script?
    File.expand_path($0) == File.expand_path(__FILE__)
  end

  def env_var_version
    ENV["BUNDLER_VERSION"]
  end

  def cli_arg_version
    return unless invoked_as_script? # don't want to hijack other binstubs
    return unless "update".start_with?(ARGV.first || " ") # must be running `bundle update`
    bundler_version = nil
    update_index = nil
    ARGV.each_with_index do |a, i|
      if update_index && update_index.succ == i && a =~ Gem::Version::ANCHORED_VERSION_PATTERN
        bundler_version = a
      end
      next unless a =~ /\A--bundler(?:[= ](#{Gem::Version::VERSION_PATTERN}))?\z/
      bundler_version = $1
      update_index = i
    end
    bundler_version
  end

  def gemfile
    gemfile = ENV["BUNDLE_GEMFILE"]
    return gemfile if gemfile && !gemfile.empty?

    File.expand_path("../Gemfile", __dir__)
  end

  def lockfile
    lockfile =
      case File.basename(gemfile)
      when "gems.rb" then gemfile.sub(/\.rb$/, gemfile)
      else "#{gemfile}.lock"
      end
    File.expand_path(lockfile)
  end

  def lockfile_version
    return unless File.file?(lockfile)
    lockfile_contents = File.read(lockfile)
    return unless lockfile_contents =~ /\n\nBUNDLED WITH\n\s{2,}(#{Gem::Version::VERSION_PATTERN})\n/
    Regexp.last_match(1)
  end

  def bundler_requirement
    @bundler_requirement ||=
      env_var_version ||
      cli_arg_version ||
      bundler_requirement_for(lockfile_version)
  end

  def bundler_requirement_for(version)
    return "#{Gem::Requirement.default}.a" unless version

    bundler_gem_version = Gem::Version.new(version)

    bundler_gem_version.approximate_recommendation
  end

  def load_bundler!
    ENV["BUNDLE_GEMFILE"] ||= gemfile

    activate_bundler
  end

  def activate_bundler
    gem_error = activation_error_handling do
      gem "bundler", bundler_requirement
    end
    return if gem_error.nil?
    require_error = activation_error_handling do
      require "bundler/version"
    end
    return if require_error.nil? && Gem::Requirement.new(bundler_requirement).satisfied_by?(Gem::Version.new(Bundler::VERSION))
    warn "Activating bundler (#{bundler_requirement}) failed:\n#{gem_error.message}\n\nTo install the version of bundler this project requires, run `gem install bundler -v '#{bundler_requirement}'`"
    exit 42
  end

  def activation_error_handling
    yield
    nil
  rescue StandardError, LoadError => e
    e
  end
end

m.load_bundler!

if m.invoked_as_script?
  load Gem.bin_path("bundler", "bundle")
end
</file>

<file path="bin/dev">
#!/usr/bin/env ruby
exec "./bin/rails", "server", *ARGV
</file>

<file path="bin/docker-entrypoint">
#!/bin/bash -e

# Enable jemalloc for reduced memory usage and latency.
if [ -z "${LD_PRELOAD+x}" ]; then
    LD_PRELOAD=$(find /usr/lib -name libjemalloc.so.2 -print -quit)
    export LD_PRELOAD
fi

# If running the rails server then create or migrate existing database
if [ "${@: -2:1}" == "./bin/rails" ] && [ "${@: -1:1}" == "server" ]; then
  ./bin/rails db:prepare
fi

exec "${@}"
</file>

<file path="bin/jobs">
#!/usr/bin/env ruby

require_relative "../config/environment"
require "solid_queue/cli"

SolidQueue::Cli.start(ARGV)
</file>

<file path="bin/kamal">
#!/usr/bin/env ruby
# frozen_string_literal: true

#
# This file was generated by Bundler.
#
# The application 'kamal' is installed as part of a gem, and
# this file is here to facilitate running it.
#

ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../Gemfile", __dir__)

bundle_binstub = File.expand_path("bundle", __dir__)

if File.file?(bundle_binstub)
  if File.read(bundle_binstub, 300).include?("This file was generated by Bundler")
    load(bundle_binstub)
  else
    abort("Your `bin/bundle` was not generated by Bundler, so this binstub cannot run.
Replace `bin/bundle` by running `bundle binstubs bundler --force`, then run this command again.")
  end
end

require "rubygems"
require "bundler/setup"

load Gem.bin_path("kamal", "kamal")
</file>

<file path="bin/rails">
#!/usr/bin/env ruby
APP_PATH = File.expand_path("../config/application", __dir__)
require_relative "../config/boot"
require "rails/commands"
</file>

<file path="bin/rake">
#!/usr/bin/env ruby
require_relative "../config/boot"
require "rake"
Rake.application.run
</file>

<file path="bin/rubocop">
#!/usr/bin/env ruby
require "rubygems"
require "bundler/setup"

# explicit rubocop config increases performance slightly while avoiding config confusion.
ARGV.unshift("--config", File.expand_path("../.rubocop.yml", __dir__))

load Gem.bin_path("rubocop", "rubocop")
</file>

<file path="bin/setup">
#!/usr/bin/env ruby
require "fileutils"

APP_ROOT = File.expand_path("..", __dir__)

def system!(*args)
  system(*args, exception: true)
end

FileUtils.chdir APP_ROOT do
  # This script is a way to set up or update your development environment automatically.
  # This script is idempotent, so that you can run it at any time and get an expectable outcome.
  # Add necessary setup steps to this file.

  puts "== Installing dependencies =="
  system("bundle check") || system!("bundle install")

  # puts "\n== Copying sample files =="
  # unless File.exist?("config/database.yml")
  #   FileUtils.cp "config/database.yml.sample", "config/database.yml"
  # end

  puts "\n== Preparing database =="
  system! "bin/rails db:prepare"

  puts "\n== Removing old logs and tempfiles =="
  system! "bin/rails log:clear tmp:clear"

  unless ARGV.include?("--skip-server")
    puts "\n== Starting development server =="
    STDOUT.flush # flush the output before exec(2) so that it displays
    exec "bin/dev"
  end
end
</file>

<file path="bin/thrust">
#!/usr/bin/env ruby
require "rubygems"
require "bundler/setup"

load Gem.bin_path("thruster", "thrust")
</file>

<file path="config/environments/development.rb">
require "active_support/core_ext/integer/time"

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # Make code changes take effect immediately without server restart.
  config.enable_reloading = true

  # Do not eager load code on boot.
  config.eager_load = false

  # Show full error reports.
  config.consider_all_requests_local = true

  # Enable server timing.
  config.server_timing = true

  # Enable/disable Action Controller caching. By default Action Controller caching is disabled.
  # Run rails dev:cache to toggle Action Controller caching.
  if Rails.root.join("tmp/caching-dev.txt").exist?
    config.public_file_server.headers = { "cache-control" => "public, max-age=#{2.days.to_i}" }
  else
    config.action_controller.perform_caching = false
  end

  # Change to :null_store to avoid any caching.
  config.cache_store = :memory_store

  # Store uploaded files on the local file system (see config/storage.yml for options).
  config.active_storage.service = :local

  # Don't care if the mailer can't send.
  config.action_mailer.raise_delivery_errors = false

  # Make template changes take effect immediately.
  config.action_mailer.perform_caching = false

  # Set localhost to be used by links generated in mailer templates.
  config.action_mailer.default_url_options = { host: "localhost", port: 3000 }

  # Print deprecation notices to the Rails logger.
  config.active_support.deprecation = :log

  # Raise an error on page load if there are pending migrations.
  config.active_record.migration_error = :page_load

  # Highlight code that triggered database queries in logs.
  config.active_record.verbose_query_logs = true

  # Append comments with runtime information tags to SQL queries in logs.
  config.active_record.query_log_tags_enabled = true

  # Highlight code that enqueued background job in logs.
  config.active_job.verbose_enqueue_logs = true

  # Raises error for missing translations.
  # config.i18n.raise_on_missing_translations = true

  # Annotate rendered view with file names.
  config.action_view.annotate_rendered_view_with_filenames = true

  # Uncomment if you wish to allow Action Cable access from any origin.
  # config.action_cable.disable_request_forgery_protection = true

  # Raise error when a before_action's only/except options reference missing actions.
  config.action_controller.raise_on_missing_callback_actions = true

  # Apply autocorrection by RuboCop to files generated by `bin/rails generate`.
  # config.generators.apply_rubocop_autocorrect_after_generate!
end
</file>

<file path="config/environments/production.rb">
require "active_support/core_ext/integer/time"

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # Code is not reloaded between requests.
  config.enable_reloading = false

  # Eager load code on boot for better performance and memory savings (ignored by Rake tasks).
  config.eager_load = true

  # Full error reports are disabled.
  config.consider_all_requests_local = false

  # Cache assets for far-future expiry since they are all digest stamped.
  config.public_file_server.headers = { "cache-control" => "public, max-age=#{1.year.to_i}" }

  # Enable serving of images, stylesheets, and JavaScripts from an asset server.
  # config.asset_host = "http://assets.example.com"

  # Store uploaded files on the local file system (see config/storage.yml for options).
  config.active_storage.service = :local

  # Assume all access to the app is happening through a SSL-terminating reverse proxy.
  config.assume_ssl = true

  # Force all access to the app over SSL, use Strict-Transport-Security, and use secure cookies.
  config.force_ssl = true

  # Skip http-to-https redirect for the default health check endpoint.
  # config.ssl_options = { redirect: { exclude: ->(request) { request.path == "/up" } } }

  # Log to STDOUT with the current request id as a default log tag.
  config.log_tags = [ :request_id ]
  config.logger   = ActiveSupport::TaggedLogging.logger(STDOUT)

  # Change to "debug" to log everything (including potentially personally-identifiable information!)
  config.log_level = ENV.fetch("RAILS_LOG_LEVEL", "info")

  # Prevent health checks from clogging up the logs.
  config.silence_healthcheck_path = "/up"

  # Don't log any deprecations.
  config.active_support.report_deprecations = false

  # Replace the default in-process memory cache store with a durable alternative.
  config.cache_store = :solid_cache_store

  # Replace the default in-process and non-durable queuing backend for Active Job.
  config.active_job.queue_adapter = :solid_queue
  config.solid_queue.connects_to = { database: { writing: :queue } }

  # Ignore bad email addresses and do not raise email delivery errors.
  # Set this to true and configure the email server for immediate delivery to raise delivery errors.
  # config.action_mailer.raise_delivery_errors = false

  # Set host to be used by links generated in mailer templates.
  config.action_mailer.default_url_options = { host: "example.com" }

  # Specify outgoing SMTP server. Remember to add smtp/* credentials via rails credentials:edit.
  # config.action_mailer.smtp_settings = {
  #   user_name: Rails.application.credentials.dig(:smtp, :user_name),
  #   password: Rails.application.credentials.dig(:smtp, :password),
  #   address: "smtp.example.com",
  #   port: 587,
  #   authentication: :plain
  # }

  # Enable locale fallbacks for I18n (makes lookups for any locale fall back to
  # the I18n.default_locale when a translation cannot be found).
  config.i18n.fallbacks = true

  # Do not dump schema after migrations.
  config.active_record.dump_schema_after_migration = false

  # Only use :id for inspections in production.
  config.active_record.attributes_for_inspect = [ :id ]

  # Enable DNS rebinding protection and other `Host` header attacks.
  # config.hosts = [
  #   "example.com",     # Allow requests from example.com
  #   /.*\.example\.com/ # Allow requests from subdomains like `www.example.com`
  # ]
  #
  # Skip DNS rebinding protection for the default health check endpoint.
  # config.host_authorization = { exclude: ->(request) { request.path == "/up" } }
end
</file>

<file path="config/environments/test.rb">
# The test environment is used exclusively to run your application's
# test suite. You never need to work with it otherwise. Remember that
# your test database is "scratch space" for the test suite and is wiped
# and recreated between test runs. Don't rely on the data there!

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # While tests run files are not watched, reloading is not necessary.
  config.enable_reloading = false

  # Eager loading loads your entire application. When running a single test locally,
  # this is usually not necessary, and can slow down your test suite. However, it's
  # recommended that you enable it in continuous integration systems to ensure eager
  # loading is working properly before deploying your code.
  config.eager_load = ENV["CI"].present?

  # Configure public file server for tests with cache-control for performance.
  config.public_file_server.headers = { "cache-control" => "public, max-age=3600" }

  # Show full error reports.
  config.consider_all_requests_local = true
  config.cache_store = :null_store

  # Render exception templates for rescuable exceptions and raise for other exceptions.
  config.action_dispatch.show_exceptions = :rescuable

  # Disable request forgery protection in test environment.
  config.action_controller.allow_forgery_protection = false

  # Store uploaded files on the local file system in a temporary directory.
  config.active_storage.service = :test

  # Tell Action Mailer not to deliver emails to the real world.
  # The :test delivery method accumulates sent emails in the
  # ActionMailer::Base.deliveries array.
  config.action_mailer.delivery_method = :test

  # Set host to be used by links generated in mailer templates.
  config.action_mailer.default_url_options = { host: "example.com" }

  # Print deprecation notices to the stderr.
  config.active_support.deprecation = :stderr

  # Raises error for missing translations.
  # config.i18n.raise_on_missing_translations = true

  # Annotate rendered view with file names.
  # config.action_view.annotate_rendered_view_with_filenames = true

  # Raise error when a before_action's only/except options reference missing actions.
  config.action_controller.raise_on_missing_callback_actions = true
end
</file>

<file path="config/initializers/cors.rb">
# Be sure to restart your server when you modify this file.

# Avoid CORS issues when API is called from the frontend app.
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin Ajax requests.

# Read more: https://github.com/cyu/rack-cors

# Rails.application.config.middleware.insert_before 0, Rack::Cors do
#   allow do
#     origins "example.com"
#
#     resource "*",
#       headers: :any,
#       methods: [:get, :post, :put, :patch, :delete, :options, :head]
#   end
# end
</file>

<file path="config/initializers/filter_parameter_logging.rb">
# Be sure to restart your server when you modify this file.

# Configure parameters to be partially matched (e.g. passw matches password) and filtered from the log file.
# Use this to limit dissemination of sensitive information.
# See the ActiveSupport::ParameterFilter documentation for supported notations and behaviors.
Rails.application.config.filter_parameters += [
  :passw, :email, :secret, :token, :_key, :crypt, :salt, :certificate, :otp, :ssn, :cvv, :cvc
]
</file>

<file path="config/initializers/inflections.rb">
# Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, "\\1en"
#   inflect.singular /^(ox)en/i, "\\1"
#   inflect.irregular "person", "people"
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym "RESTful"
# end
</file>

<file path="config/locales/en.yml">
# Files in the config/locales directory are used for internationalization and
# are automatically loaded by Rails. If you want to use locales other than
# English, add the necessary files in this directory.
#
# To use the locales, use `I18n.t`:
#
#     I18n.t "hello"
#
# In views, this is aliased to just `t`:
#
#     <%= t("hello") %>
#
# To use a different locale, set it with `I18n.locale`:
#
#     I18n.locale = :es
#
# This would use the information in config/locales/es.yml.
#
# To learn more about the API, please read the Rails Internationalization guide
# at https://guides.rubyonrails.org/i18n.html.
#
# Be aware that YAML interprets the following case-insensitive strings as
# booleans: `true`, `false`, `on`, `off`, `yes`, `no`. Therefore, these strings
# must be quoted to be interpreted as strings. For example:
#
#     en:
#       "yes": yup
#       enabled: "ON"

en:
  hello: "Hello world"
</file>

<file path="config/boot.rb">
ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../Gemfile", __dir__)

require "bundler/setup" # Set up gems listed in the Gemfile.
</file>

<file path="config/cable.yml">
# Async adapter only works within the same process, so for manually triggering cable updates from a console,
# and seeing results in the browser, you must do so from the web console (running inside the dev process),
# not a terminal started via bin/rails console! Add "console" to any action or any ERB template view
# to make the web console appear.
development:
  adapter: async

test:
  adapter: test

production:
  adapter: solid_cable
  connects_to:
    database:
      writing: cable
  polling_interval: 0.1.seconds
  message_retention: 1.day
</file>

<file path="config/cache.yml">
default: &default
  store_options:
    # Cap age of oldest cache entry to fulfill retention policies
    # max_age: <%= 60.days.to_i %>
    max_size: <%= 256.megabytes %>
    namespace: <%= Rails.env %>

development:
  <<: *default

test:
  <<: *default

production:
  database: cache
  <<: *default
</file>

<file path="config/credentials.yml.enc">
1orVU7caZnVgRCJogBhK3Wd/TQ6nwvGde1Dn+fOTQC6AHwGF3YfVouF+wAJcT0jObvFXAVgh6vGZYI3Zkkb4jiyyH+pd3TSOPl5efQ2PPkffvdiUOUxz6NbfFtOFzF6zvogvIlbpHYwj8lHQ/uIkVE3Q83uMpnwaNdUwrDj7WTMh+MvVWwO4DQnfiXxxAElsU2QUbPwScj5yUxQ5JxLNEIHCgOBziuZ79eyTIDSfIgzhDjbtFIIYeCNtKytAMC2JGdx7BLEArjOCicX3Zy/bzrqw4MOIERzKgnGcIK5Z4L6/wUBlvYQh3jyD7qLqwxj9U5YfaVVa0lKPXWb+puvNn3fBuFs8KRz9P3nW0v2k5+3rEt4ZDLkv6ZL1vdKDT2q3v0mgZBKVrvndyZeOxZ6bdhQgVLmTi0pusa1smzqtFC0AtwQsjY4gOA4B/HlXP5hGTsjwR9e27qxxN9j0Ta2w6qQC4Zx4xl61plPKSf1sas8t3YLokbYaEV/6--uOTuNxMJNwLiQJq1--53S9FKCvVoPndT0L2rdu4w==
</file>

<file path="config/deploy.yml">
# Name of your application. Used to uniquely configure containers.
service: carestack

# Name of the container image.
image: your-user/carestack

# Deploy to these servers.
servers:
  web:
    - 192.168.0.1
  # job:
  #   hosts:
  #     - 192.168.0.1
  #   cmd: bin/jobs

# Enable SSL auto certification via Let's Encrypt and allow for multiple apps on a single web server.
# Remove this section when using multiple web servers and ensure you terminate SSL at your load balancer.
#
# Note: If using Cloudflare, set encryption mode in SSL/TLS setting to "Full" to enable CF-to-app encryption.
proxy:
  ssl: true
  host: app.example.com

# Credentials for your image host.
registry:
  # Specify the registry server, if you're not using Docker Hub
  # server: registry.digitalocean.com / ghcr.io / ...
  username: your-user

  # Always use an access token rather than real password when possible.
  password:
    - KAMAL_REGISTRY_PASSWORD

# Inject ENV variables into containers (secrets come from .kamal/secrets).
env:
  secret:
    - RAILS_MASTER_KEY
  clear:
    # Run the Solid Queue Supervisor inside the web server's Puma process to do jobs.
    # When you start using multiple servers, you should split out job processing to a dedicated machine.
    SOLID_QUEUE_IN_PUMA: true

    # Set number of processes dedicated to Solid Queue (default: 1)
    # JOB_CONCURRENCY: 3

    # Set number of cores available to the application on each server (default: 1).
    # WEB_CONCURRENCY: 2

    # Match this to any external database server to configure Active Record correctly
    # Use carestack-db for a db accessory server on same machine via local kamal docker network.
    # DB_HOST: 192.168.0.2

    # Log everything from Rails
    # RAILS_LOG_LEVEL: debug

# Aliases are triggered with "bin/kamal <alias>". You can overwrite arguments on invocation:
# "bin/kamal logs -r job" will tail logs from the first server in the job section.
aliases:
  console: app exec --interactive --reuse "bin/rails console"
  shell: app exec --interactive --reuse "bash"
  logs: app logs -f
  dbc: app exec --interactive --reuse "bin/rails dbconsole"


# Use a persistent storage volume for sqlite database files and local Active Storage files.
# Recommended to change this to a mounted volume path that is backed up off server.
volumes:
  - "carestack_storage:/rails/storage"


# Bridge fingerprinted assets, like JS and CSS, between versions to avoid
# hitting 404 on in-flight requests. Combines all files from new and old
# version inside the asset_path.
asset_path: /rails/public/assets

# Configure the image builder.
builder:
  arch: amd64

  # # Build image via remote server (useful for faster amd64 builds on arm64 computers)
  # remote: ssh://docker@docker-builder-server
  #
  # # Pass arguments and secrets to the Docker build process
  # args:
  #   RUBY_VERSION: 3.2.0
  # secrets:
  #   - GITHUB_TOKEN
  #   - RAILS_MASTER_KEY

# Use a different ssh user than root
# ssh:
#   user: app

# Use accessory services (secrets come from .kamal/secrets).
# accessories:
#   db:
#     image: mysql:8.0
#     host: 192.168.0.2
#     # Change to 3306 to expose port to the world instead of just local network.
#     port: "127.0.0.1:3306:3306"
#     env:
#       clear:
#         MYSQL_ROOT_HOST: '%'
#       secret:
#         - MYSQL_ROOT_PASSWORD
#     files:
#       - config/mysql/production.cnf:/etc/mysql/my.cnf
#       - db/production.sql:/docker-entrypoint-initdb.d/setup.sql
#     directories:
#       - data:/var/lib/mysql
#   redis:
#     image: redis:7.0
#     host: 192.168.0.2
#     port: 6379
#     directories:
#       - data:/data
</file>

<file path="config/environment.rb">
# Load the Rails application.
require_relative "application"

# Initialize the Rails application.
Rails.application.initialize!
</file>

<file path="config/puma.rb">
# This configuration file will be evaluated by Puma. The top-level methods that
# are invoked here are part of Puma's configuration DSL. For more information
# about methods provided by the DSL, see https://puma.io/puma/Puma/DSL.html.
#
# Puma starts a configurable number of processes (workers) and each process
# serves each request in a thread from an internal thread pool.
#
# You can control the number of workers using ENV["WEB_CONCURRENCY"]. You
# should only set this value when you want to run 2 or more workers. The
# default is already 1.
#
# The ideal number of threads per worker depends both on how much time the
# application spends waiting for IO operations and on how much you wish to
# prioritize throughput over latency.
#
# As a rule of thumb, increasing the number of threads will increase how much
# traffic a given process can handle (throughput), but due to CRuby's
# Global VM Lock (GVL) it has diminishing returns and will degrade the
# response time (latency) of the application.
#
# The default is set to 3 threads as it's deemed a decent compromise between
# throughput and latency for the average Rails application.
#
# Any libraries that use a connection pool or another resource pool should
# be configured to provide at least as many connections as the number of
# threads. This includes Active Record's `pool` parameter in `database.yml`.
threads_count = ENV.fetch("RAILS_MAX_THREADS", 3)
threads threads_count, threads_count

# Specifies the `port` that Puma will listen on to receive requests; default is 3000.
port ENV.fetch("PORT", 3000)

# Allow puma to be restarted by `bin/rails restart` command.
plugin :tmp_restart

# Run the Solid Queue supervisor inside of Puma for single-server deployments
plugin :solid_queue if ENV["SOLID_QUEUE_IN_PUMA"]

# Specify the PID file. Defaults to tmp/pids/server.pid in development.
# In other environments, only set the PID file if requested.
pidfile ENV["PIDFILE"] if ENV["PIDFILE"]
</file>

<file path="config/queue.yml">
default: &default
  dispatchers:
    - polling_interval: 1
      batch_size: 500
  workers:
    - queues: "*"
      threads: 3
      processes: <%= ENV.fetch("JOB_CONCURRENCY", 1) %>
      polling_interval: 0.1

development:
  <<: *default

test:
  <<: *default

production:
  <<: *default
</file>

<file path="config/recurring.yml">
# examples:
#   periodic_cleanup:
#     class: CleanSoftDeletedRecordsJob
#     queue: background
#     args: [ 1000, { batch_size: 500 } ]
#     schedule: every hour
#   periodic_cleanup_with_command:
#     command: "SoftDeletedRecord.due.delete_all"
#     priority: 2
#     schedule: at 5am every day

production:
  clear_solid_queue_finished_jobs:
    command: "SolidQueue::Job.clear_finished_in_batches(sleep_between_batches: 0.3)"
    schedule: every hour at minute 12
</file>

<file path="config/storage.yml">
test:
  service: Disk
  root: <%= Rails.root.join("tmp/storage") %>

local:
  service: Disk
  root: <%= Rails.root.join("storage") %>

# Use bin/rails credentials:edit to set the AWS secrets (as aws:access_key_id|secret_access_key)
# amazon:
#   service: S3
#   access_key_id: <%= Rails.application.credentials.dig(:aws, :access_key_id) %>
#   secret_access_key: <%= Rails.application.credentials.dig(:aws, :secret_access_key) %>
#   region: us-east-1
#   bucket: your_own_bucket-<%= Rails.env %>

# Remember not to checkin your GCS keyfile to a repository
# google:
#   service: GCS
#   project: your_project
#   credentials: <%= Rails.root.join("path/to/gcs.keyfile") %>
#   bucket: your_own_bucket-<%= Rails.env %>

# Use bin/rails credentials:edit to set the Azure Storage secret (as azure_storage:storage_access_key)
# microsoft:
#   service: AzureStorage
#   storage_account_name: your_account_name
#   storage_access_key: <%= Rails.application.credentials.dig(:azure_storage, :storage_access_key) %>
#   container: your_container_name-<%= Rails.env %>

# mirror:
#   service: Mirror
#   primary: local
#   mirrors: [ amazon, google, microsoft ]
</file>

<file path="db/migrate/20250831202143_create_verticals.rb">
class CreateVerticals < ActiveRecord::Migration[8.0]
  def change
    create_table :verticals do |t|
      t.string :name
      t.string :slug
      t.text :description
      t.boolean :active

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250831202159_create_accounts.rb">
class CreateAccounts < ActiveRecord::Migration[8.0]
  def change
    create_table :accounts do |t|
      t.string :name
      t.references :vertical, null: false, foreign_key: true
      t.string :email
      t.string :phone

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250831202216_create_service_types.rb">
class CreateServiceTypes < ActiveRecord::Migration[8.0]
  def change
    create_table :service_types do |t|
      t.string :name
      t.references :vertical, null: false, foreign_key: true
      t.integer :duration_minutes
      t.boolean :requires_background_check
      t.decimal :min_staff_ratio

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250831202229_create_customers.rb">
class CreateCustomers < ActiveRecord::Migration[8.0]
  def change
    create_table :customers do |t|
      t.references :account, null: false, foreign_key: true
      t.string :first_name
      t.string :last_name
      t.string :email
      t.string :phone
      t.text :address

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250831202241_create_staffs.rb">
class CreateStaffs < ActiveRecord::Migration[8.0]
  def change
    create_table :staffs do |t|
      t.references :account, null: false, foreign_key: true
      t.string :first_name
      t.string :last_name
      t.string :email
      t.string :phone
      t.boolean :background_check_passed

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250831202253_create_appointments.rb">
class CreateAppointments < ActiveRecord::Migration[8.0]
  def change
    create_table :appointments do |t|
      t.references :account, null: false, foreign_key: true
      t.references :customer, null: false, foreign_key: true
      t.references :service_type, null: false, foreign_key: true
      t.references :staff, null: false, foreign_key: true
      t.datetime :scheduled_at
      t.integer :duration_minutes
      t.string :status
      t.text :notes

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250904185504_create_routes.rb">
class CreateRoutes < ActiveRecord::Migration[8.0]
  def change
    create_table :routes do |t|
      t.references :account, null: false, foreign_key: true
      t.date :scheduled_date
      t.string :status
      t.integer :total_distance_meters
      t.integer :total_duration_seconds

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250904185532_create_route_stops.rb">
class CreateRouteStops < ActiveRecord::Migration[8.0]
  def change
    create_table :route_stops do |t|
      t.references :route, null: false, foreign_key: true
      t.references :appointment, null: false, foreign_key: true
      t.integer :stop_order
      t.datetime :estimated_arrival
      t.datetime :estimated_departure
      t.datetime :actual_arrival
      t.datetime :actual_departure

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250904185606_create_optimization_jobs.rb">
class CreateOptimizationJobs < ActiveRecord::Migration[8.0]
  def change
    create_table :optimization_jobs do |t|
      t.references :account, null: false, foreign_key: true
      t.date :requested_date
      t.string :status
      t.json :parameters
      t.json :result
      t.datetime :processing_started_at
      t.datetime :processing_completed_at

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250904185634_add_location_fields_to_customers.rb">
class AddLocationFieldsToCustomers < ActiveRecord::Migration[8.0]
  def change
    add_column :customers, :latitude, :decimal
    add_column :customers, :longitude, :decimal
    add_column :customers, :geocoded_address, :string
  end
end
</file>

<file path="db/migrate/20250904185646_add_location_fields_to_staff.rb">
class AddLocationFieldsToStaff < ActiveRecord::Migration[8.0]
  def change
    add_column :staffs, :home_latitude, :decimal
    add_column :staffs, :home_longitude, :decimal
    add_column :staffs, :max_travel_radius_km, :integer
  end
end
</file>

<file path="db/cable_schema.rb">
ActiveRecord::Schema[7.1].define(version: 1) do
  create_table "solid_cable_messages", force: :cascade do |t|
    t.binary "channel", limit: 1024, null: false
    t.binary "payload", limit: 536870912, null: false
    t.datetime "created_at", null: false
    t.integer "channel_hash", limit: 8, null: false
    t.index ["channel"], name: "index_solid_cable_messages_on_channel"
    t.index ["channel_hash"], name: "index_solid_cable_messages_on_channel_hash"
    t.index ["created_at"], name: "index_solid_cable_messages_on_created_at"
  end
end
</file>

<file path="db/cache_schema.rb">
# frozen_string_literal: true

ActiveRecord::Schema[7.2].define(version: 1) do
  create_table "solid_cache_entries", force: :cascade do |t|
    t.binary "key", limit: 1024, null: false
    t.binary "value", limit: 536870912, null: false
    t.datetime "created_at", null: false
    t.integer "key_hash", limit: 8, null: false
    t.integer "byte_size", limit: 4, null: false
    t.index ["byte_size"], name: "index_solid_cache_entries_on_byte_size"
    t.index ["key_hash", "byte_size"], name: "index_solid_cache_entries_on_key_hash_and_byte_size"
    t.index ["key_hash"], name: "index_solid_cache_entries_on_key_hash", unique: true
  end
end
</file>

<file path="db/queue_schema.rb">
ActiveRecord::Schema[7.1].define(version: 1) do
  create_table "solid_queue_blocked_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.string "queue_name", null: false
    t.integer "priority", default: 0, null: false
    t.string "concurrency_key", null: false
    t.datetime "expires_at", null: false
    t.datetime "created_at", null: false
    t.index [ "concurrency_key", "priority", "job_id" ], name: "index_solid_queue_blocked_executions_for_release"
    t.index [ "expires_at", "concurrency_key" ], name: "index_solid_queue_blocked_executions_for_maintenance"
    t.index [ "job_id" ], name: "index_solid_queue_blocked_executions_on_job_id", unique: true
  end

  create_table "solid_queue_claimed_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.bigint "process_id"
    t.datetime "created_at", null: false
    t.index [ "job_id" ], name: "index_solid_queue_claimed_executions_on_job_id", unique: true
    t.index [ "process_id", "job_id" ], name: "index_solid_queue_claimed_executions_on_process_id_and_job_id"
  end

  create_table "solid_queue_failed_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.text "error"
    t.datetime "created_at", null: false
    t.index [ "job_id" ], name: "index_solid_queue_failed_executions_on_job_id", unique: true
  end

  create_table "solid_queue_jobs", force: :cascade do |t|
    t.string "queue_name", null: false
    t.string "class_name", null: false
    t.text "arguments"
    t.integer "priority", default: 0, null: false
    t.string "active_job_id"
    t.datetime "scheduled_at"
    t.datetime "finished_at"
    t.string "concurrency_key"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index [ "active_job_id" ], name: "index_solid_queue_jobs_on_active_job_id"
    t.index [ "class_name" ], name: "index_solid_queue_jobs_on_class_name"
    t.index [ "finished_at" ], name: "index_solid_queue_jobs_on_finished_at"
    t.index [ "queue_name", "finished_at" ], name: "index_solid_queue_jobs_for_filtering"
    t.index [ "scheduled_at", "finished_at" ], name: "index_solid_queue_jobs_for_alerting"
  end

  create_table "solid_queue_pauses", force: :cascade do |t|
    t.string "queue_name", null: false
    t.datetime "created_at", null: false
    t.index [ "queue_name" ], name: "index_solid_queue_pauses_on_queue_name", unique: true
  end

  create_table "solid_queue_processes", force: :cascade do |t|
    t.string "kind", null: false
    t.datetime "last_heartbeat_at", null: false
    t.bigint "supervisor_id"
    t.integer "pid", null: false
    t.string "hostname"
    t.text "metadata"
    t.datetime "created_at", null: false
    t.string "name", null: false
    t.index [ "last_heartbeat_at" ], name: "index_solid_queue_processes_on_last_heartbeat_at"
    t.index [ "name", "supervisor_id" ], name: "index_solid_queue_processes_on_name_and_supervisor_id", unique: true
    t.index [ "supervisor_id" ], name: "index_solid_queue_processes_on_supervisor_id"
  end

  create_table "solid_queue_ready_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.string "queue_name", null: false
    t.integer "priority", default: 0, null: false
    t.datetime "created_at", null: false
    t.index [ "job_id" ], name: "index_solid_queue_ready_executions_on_job_id", unique: true
    t.index [ "priority", "job_id" ], name: "index_solid_queue_poll_all"
    t.index [ "queue_name", "priority", "job_id" ], name: "index_solid_queue_poll_by_queue"
  end

  create_table "solid_queue_recurring_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.string "task_key", null: false
    t.datetime "run_at", null: false
    t.datetime "created_at", null: false
    t.index [ "job_id" ], name: "index_solid_queue_recurring_executions_on_job_id", unique: true
    t.index [ "task_key", "run_at" ], name: "index_solid_queue_recurring_executions_on_task_key_and_run_at", unique: true
  end

  create_table "solid_queue_recurring_tasks", force: :cascade do |t|
    t.string "key", null: false
    t.string "schedule", null: false
    t.string "command", limit: 2048
    t.string "class_name"
    t.text "arguments"
    t.string "queue_name"
    t.integer "priority", default: 0
    t.boolean "static", default: true, null: false
    t.text "description"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index [ "key" ], name: "index_solid_queue_recurring_tasks_on_key", unique: true
    t.index [ "static" ], name: "index_solid_queue_recurring_tasks_on_static"
  end

  create_table "solid_queue_scheduled_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.string "queue_name", null: false
    t.integer "priority", default: 0, null: false
    t.datetime "scheduled_at", null: false
    t.datetime "created_at", null: false
    t.index [ "job_id" ], name: "index_solid_queue_scheduled_executions_on_job_id", unique: true
    t.index [ "scheduled_at", "priority", "job_id" ], name: "index_solid_queue_dispatch_all"
  end

  create_table "solid_queue_semaphores", force: :cascade do |t|
    t.string "key", null: false
    t.integer "value", default: 1, null: false
    t.datetime "expires_at", null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index [ "expires_at" ], name: "index_solid_queue_semaphores_on_expires_at"
    t.index [ "key", "value" ], name: "index_solid_queue_semaphores_on_key_and_value"
    t.index [ "key" ], name: "index_solid_queue_semaphores_on_key", unique: true
  end

  add_foreign_key "solid_queue_blocked_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
  add_foreign_key "solid_queue_claimed_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
  add_foreign_key "solid_queue_failed_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
  add_foreign_key "solid_queue_ready_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
  add_foreign_key "solid_queue_recurring_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
  add_foreign_key "solid_queue_scheduled_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
end
</file>

<file path="db/seeds.rb">
# This file should ensure the existence of records required to run the application in every environment (production,
# development, test). The code here should be idempotent so that it can be executed at any point in every environment.
# The data can then be loaded with the bin/rails db:seed command (or created alongside the database with db:setup).
#
# Example:
#
#   ["Action", "Comedy", "Drama", "Horror"].each do |genre_name|
#     MovieGenre.find_or_create_by!(name: genre_name)
#   end
</file>

<file path="lib/tasks/.keep">

</file>

<file path="log/.keep">

</file>

<file path="public/robots.txt">
# See https://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file
</file>

<file path="script/.keep">

</file>

<file path="spec/factories/accounts.rb">
FactoryBot.define do
  factory :account do
    name { "MyString" }
    vertical { nil }
    email { "MyString" }
    phone { "MyString" }
  end
end
</file>

<file path="spec/factories/appointments.rb">
FactoryBot.define do
  factory :appointment do
    account { nil }
    customer { nil }
    service_type { nil }
    staff { nil }
    scheduled_at { "2025-08-31 14:22:53" }
    duration_minutes { 1 }
    status { "MyString" }
    notes { "MyText" }
  end
end
</file>

<file path="spec/factories/customers.rb">
FactoryBot.define do
  factory :customer do
    account { nil }
    first_name { "MyString" }
    last_name { "MyString" }
    email { "MyString" }
    phone { "MyString" }
    address { "MyText" }
  end
end
</file>

<file path="spec/factories/optimization_jobs.rb">
FactoryBot.define do
  factory :optimization_job do
    account { nil }
    requested_date { "2025-09-04" }
    status { "MyString" }
    parameters { "" }
    result { "" }
    processing_started_at { "2025-09-04 12:56:06" }
    processing_completed_at { "2025-09-04 12:56:06" }
  end
end
</file>

<file path="spec/factories/route_stops.rb">
FactoryBot.define do
  factory :route_stop do
    route { nil }
    appointment { nil }
    stop_order { 1 }
    estimated_arrival { "2025-09-04 12:55:32" }
    estimated_departure { "2025-09-04 12:55:32" }
    actual_arrival { "2025-09-04 12:55:32" }
    actual_departure { "2025-09-04 12:55:32" }
  end
end
</file>

<file path="spec/factories/routes.rb">
FactoryBot.define do
  factory :route do
    account { nil }
    scheduled_date { "2025-09-04" }
    status { "MyString" }
    total_distance_meters { 1 }
    total_duration_seconds { 1 }
  end
end
</file>

<file path="spec/factories/service_types.rb">
FactoryBot.define do
  factory :service_type do
    name { "MyString" }
    vertical { nil }
    duration_minutes { 1 }
    requires_background_check { false }
    min_staff_ratio { "9.99" }
  end
end
</file>

<file path="spec/factories/staffs.rb">
FactoryBot.define do
  factory :staff do
    account { nil }
    first_name { "MyString" }
    last_name { "MyString" }
    email { "MyString" }
    phone { "MyString" }
    background_check_passed { false }
  end
end
</file>

<file path="spec/factories/travel_segments.rb">
FactoryBot.define do
  factory :travel_segment do
    from_appointment { nil }
    to_appointment { nil }
    distance_meters { 1 }
    duration_seconds { 1 }
    traffic_factor { "9.99" }
  end
end
</file>

<file path="spec/factories/verticals.rb">
FactoryBot.define do
  factory :vertical do
    name { "MyString" }
    slug { "MyString" }
    description { "MyText" }
    active { false }
  end
end
</file>

<file path="spec/models/account_spec.rb">
require 'rails_helper'

RSpec.describe Account, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/appointment_spec.rb">
require 'rails_helper'

RSpec.describe Appointment, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/customer_spec.rb">
require 'rails_helper'

RSpec.describe Customer, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/optimization_job_spec.rb">
require 'rails_helper'

RSpec.describe OptimizationJob, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/route_spec.rb">
require 'rails_helper'

RSpec.describe Route, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/route_stop_spec.rb">
require 'rails_helper'

RSpec.describe RouteStop, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/service_type_spec.rb">
require 'rails_helper'

RSpec.describe ServiceType, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/staff_spec.rb">
require 'rails_helper'

RSpec.describe Staff, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/travel_segment_spec.rb">
require 'rails_helper'

RSpec.describe TravelSegment, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/vertical_spec.rb">
require 'rails_helper'

RSpec.describe Vertical, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="storage/.keep">

</file>

<file path=".dockerignore">
# See https://docs.docker.com/engine/reference/builder/#dockerignore-file for more about ignoring files.

# Ignore git directory.
/.git/
/.gitignore

# Ignore bundler config.
/.bundle

# Ignore all environment files.
/.env*

# Ignore all default key files.
/config/master.key
/config/credentials/*.key

# Ignore all logfiles and tempfiles.
/log/*
/tmp/*
!/log/.keep
!/tmp/.keep

# Ignore pidfiles, but keep the directory.
/tmp/pids/*
!/tmp/pids/.keep

# Ignore storage (uploaded files in development and any SQLite databases).
/storage/*
!/storage/.keep
/tmp/storage/*
!/tmp/storage/.keep

# Ignore CI service files.
/.github

# Ignore Kamal files.
/config/deploy*.yml
/.kamal

# Ignore development files
/.devcontainer

# Ignore Docker-related files
/.dockerignore
/Dockerfile*
</file>

<file path=".gitattributes">
# See https://git-scm.com/docs/gitattributes for more about git attribute files.

# Mark the database schema as having been generated.
db/schema.rb linguist-generated

# Mark any vendored files as having been vendored.
vendor/* linguist-vendored
config/credentials/*.yml.enc diff=rails_credentials
config/credentials.yml.enc diff=rails_credentials
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files for more about ignoring files.
#
# Temporary files generated by your text editor or operating system
# belong in git's global ignore instead:
# `$XDG_CONFIG_HOME/git/ignore` or `~/.config/git/ignore`

# Ignore bundler config.
/.bundle

# Ignore all environment files.
/.env*

# Ignore all logfiles and tempfiles.
/log/*
/tmp/*
!/log/.keep
!/tmp/.keep

# Ignore pidfiles, but keep the directory.
/tmp/pids/*
!/tmp/pids/
!/tmp/pids/.keep

# Ignore storage (uploaded files in development and any SQLite databases).
/storage/*
!/storage/.keep
/tmp/storage/*
!/tmp/storage/
!/tmp/storage/.keep

# Ignore master key for decrypting credentials and more.
/config/master.key
</file>

<file path=".rubocop.yml">
# Omakase Ruby styling for Rails
inherit_gem: { rubocop-rails-omakase: rubocop.yml }

# Overwrite or add rules to create your own house style
#
# # Use `[a, [b, c]]` not `[ a, [ b, c ] ]`
# Layout/SpaceInsideArrayLiteralBrackets:
#   Enabled: false
</file>

<file path=".ruby-version">
3.2.0
</file>

<file path="config.ru">
# This file is used by Rack-based servers to start the application.

require_relative "config/environment"

run Rails.application
Rails.application.load_server
</file>

<file path="Dockerfile">
# syntax=docker/dockerfile:1
# check=error=true

# This Dockerfile is designed for production, not development. Use with Kamal or build'n'run by hand:
# docker build -t carestack .
# docker run -d -p 80:80 -e RAILS_MASTER_KEY=<value from config/master.key> --name carestack carestack

# For a containerized dev environment, see Dev Containers: https://guides.rubyonrails.org/getting_started_with_devcontainer.html

# Make sure RUBY_VERSION matches the Ruby version in .ruby-version
ARG RUBY_VERSION=3.2.0
FROM docker.io/library/ruby:$RUBY_VERSION-slim AS base

# Rails app lives here
WORKDIR /rails

# Install base packages
RUN apt-get update -qq && \
    apt-get install --no-install-recommends -y curl libjemalloc2 libvips postgresql-client && \
    rm -rf /var/lib/apt/lists /var/cache/apt/archives

# Set production environment
ENV RAILS_ENV="production" \
    BUNDLE_DEPLOYMENT="1" \
    BUNDLE_PATH="/usr/local/bundle" \
    BUNDLE_WITHOUT="development"

# Throw-away build stage to reduce size of final image
FROM base AS build

# Install packages needed to build gems
RUN apt-get update -qq && \
    apt-get install --no-install-recommends -y build-essential git libpq-dev libyaml-dev pkg-config && \
    rm -rf /var/lib/apt/lists /var/cache/apt/archives

# Install application gems
COPY Gemfile Gemfile.lock ./
RUN bundle install && \
    rm -rf ~/.bundle/ "${BUNDLE_PATH}"/ruby/*/cache "${BUNDLE_PATH}"/ruby/*/bundler/gems/*/.git

# Copy application code
COPY . .




# Final stage for app image
FROM base

# Copy built artifacts: gems, application
COPY --from=build "${BUNDLE_PATH}" "${BUNDLE_PATH}"
COPY --from=build /rails /rails

# Run and own only the runtime files as a non-root user for security
RUN groupadd --system --gid 1000 rails && \
    useradd rails --uid 1000 --gid 1000 --create-home --shell /bin/bash && \
    chown -R rails:rails db log storage tmp
USER 1000:1000

# Entrypoint prepares the database.
ENTRYPOINT ["/rails/bin/docker-entrypoint"]

# Start server via Thruster by default, this can be overwritten at runtime
EXPOSE 80
CMD ["./bin/thrust", "./bin/rails", "server"]
</file>

<file path="Rakefile">
# Add your own tasks in files placed in lib/tasks ending in .rake,
# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.

require_relative "config/application"

Rails.application.load_tasks
</file>

<file path="README.md">
# README

This README would normally document whatever steps are necessary to get the
application up and running.

Things you may want to cover:

* Ruby version

* System dependencies

* Configuration

* Database creation

* Database initialization

* How to run the test suite

* Services (job queues, cache servers, search engines, etc.)

* Deployment instructions

* ...
</file>

<file path="s: 456 Oak Ave, Senior Community">
SSUUMMMMAARRYY OOFF LLEESSSS CCOOMMMMAANNDDSS

      Commands marked with * may be preceded by a number, _N.
      Notes in parentheses indicate the behavior if _N is given.
      A key preceded by a caret indicates the Ctrl key; thus ^K is ctrl-K.

  h  H                 Display this help.
  q  :q  Q  :Q  ZZ     Exit.
 ---------------------------------------------------------------------------

                           MMOOVVIINNGG

  e  ^E  j  ^N  CR  *  Forward  one line   (or _N lines).
  y  ^Y  k  ^K  ^P  *  Backward one line   (or _N lines).
  f  ^F  ^V  SPACE  *  Forward  one window (or _N lines).
  b  ^B  ESC-v      *  Backward one window (or _N lines).
  z                 *  Forward  one window (and set window to _N).
  w                 *  Backward one window (and set window to _N).
  ESC-SPACE         *  Forward  one window, but don't stop at end-of-file.
  d  ^D             *  Forward  one half-window (and set half-window to _N).
  u  ^U             *  Backward one half-window (and set half-window to _N).
  ESC-)  RightArrow *  Right one half screen width (or _N positions).
  ESC-(  LeftArrow  *  Left  one half screen width (or _N positions).
  ESC-}  ^RightArrow   Right to last column displayed.
  ESC-{  ^LeftArrow    Left  to first column.
  F                    Forward forever; like "tail -f".
  ESC-F                Like F but stop when search pattern is found.
  r  ^R  ^L            Repaint screen.
  R                    Repaint screen, discarding buffered input.
        ---------------------------------------------------
        Default "window" is the screen height.
        Default "half-window" is half of the screen height.
 ---------------------------------------------------------------------------

                          SSEEAARRCCHHIINNGG

  /_p_a_t_t_e_r_n          *  Search forward for (_N-th) matching line.
  ?_p_a_t_t_e_r_n          *  Search backward for (_N-th) matching line.
  n                 *  Repeat previous search (for _N-th occurrence).
  N                 *  Repeat previous search in reverse direction.
  ESC-n             *  Repeat previous search, spanning files.
  ESC-N             *  Repeat previous search, reverse dir. & spanning files.
  ESC-u                Undo (toggle) search highlighting.
  ESC-U                Clear search highlighting.
  &_p_a_t_t_e_r_n          *  Display only matching lines.
        ---------------------------------------------------
        A search pattern may begin with one or more of:
        ^N or !  Search for NON-matching lines.
        ^E or *  Search multiple files (pass thru END OF FILE).
        ^F or @  Start search at FIRST file (for /) or last file (for ?).
        ^K       Highlight matches, but don't move (KEEP position).
        ^R       Don't use REGULAR EXPRESSIONS.
        ^W       WRAP search if no match found.
 ---------------------------------------------------------------------------

                           JJUUMMPPIINNGG

  g  <  ESC-<       *  Go to first line in file (or line _N).
  G  >  ESC->       *  Go to last line in file (or line _N).
  p  %              *  Go to beginning of file (or _N percent into file).
  t                 *  Go to the (_N-th) next tag.
  T                 *  Go to the (_N-th) previous tag.
  {  (  [           *  Find close bracket } ) ].
  }  )  ]           *  Find open bracket { ( [.
  ESC-^F _<_c_1_> _<_c_2_>  *  Find close bracket _<_c_2_>.
  ESC-^B _<_c_1_> _<_c_2_>  *  Find open bracket _<_c_1_>.
        ---------------------------------------------------
        Each "find close bracket" command goes forward to the close bracket 
          matching the (_N-th) open bracket in the top line.
        Each "find open bracket" command goes backward to the open bracket 
          matching the (_N-th) close bracket in the bottom line.

  m_<_l_e_t_t_e_r_>            Mark the current top line with <letter>.
  M_<_l_e_t_t_e_r_>            Mark the current bottom line with <letter>.
  '_<_l_e_t_t_e_r_>            Go to a previously marked position.
  ''                   Go to the previous position.
  ^X^X                 Same as '.
  ESC-M_<_l_e_t_t_e_r_>        Clear a mark.
        ---------------------------------------------------
        A mark is any upper-case or lower-case letter.
        Certain marks are predefined:
             ^  means  beginning of the file
             $  means  end of the file
 ---------------------------------------------------------------------------

                        CCHHAANNGGIINNGG FFIILLEESS

  :e [_f_i_l_e]            Examine a new file.
  ^X^V                 Same as :e.
  :n                *  Examine the (_N-th) next file from the command line.
  :p                *  Examine the (_N-th) previous file from the command line.
  :x                *  Examine the first (or _N-th) file from the command line.
  :d                   Delete the current file from the command line list.
  =  ^G  :f            Print current file name.
 ---------------------------------------------------------------------------

                    MMIISSCCEELLLLAANNEEOOUUSS CCOOMMMMAANNDDSS

  -_<_f_l_a_g_>              Toggle a command line option [see OPTIONS below].
  --_<_n_a_m_e_>             Toggle a command line option, by name.
  __<_f_l_a_g_>              Display the setting of a command line option.
  ___<_n_a_m_e_>             Display the setting of an option, by name.
  +_c_m_d                 Execute the less cmd each time a new file is examined.

  !_c_o_m_m_a_n_d             Execute the shell command with $SHELL.
  |XX_c_o_m_m_a_n_d            Pipe file between current pos & mark XX to shell command.
  s _f_i_l_e               Save input to a file.
  v                    Edit the current file with $VISUAL or $EDITOR.
  V                    Print version number of "less".
 ---------------------------------------------------------------------------

                           OOPPTTIIOONNSS

        Most options may be changed either on the command line,
        or from within less by using the - or -- command.
        Options may be given in one of two forms: either a single
        character preceded by a -, or a name preceded by --.

  -?  ........  --help
                  Display help (from command line).
  -a  ........  --search-skip-screen
                  Search skips current screen.
  -A  ........  --SEARCH-SKIP-SCREEN
                  Search starts just after target line.
  -b [_N]  ....  --buffers=[_N]
                  Number of buffers.
  -B  ........  --auto-buffers
                  Don't automatically allocate buffers for pipes.
  -c  ........  --clear-screen
                  Repaint by clearing rather than scrolling.
  -d  ........  --dumb
                  Dumb terminal.
  -D xx_c_o_l_o_r  .  --color=xx_c_o_l_o_r
                  Set screen colors.
  -e  -E  ....  --quit-at-eof  --QUIT-AT-EOF
                  Quit at end of file.
  -f  ........  --force
                  Force open non-regular files.
  -F  ........  --quit-if-one-screen
                  Quit if entire file fits on first screen.
  -g  ........  --hilite-search
                  Highlight only last match for searches.
  -G  ........  --HILITE-SEARCH
                  Don't highlight any matches for searches.
  -h [_N]  ....  --max-back-scroll=[_N]
                  Backward scroll limit.
  -i  ........  --ignore-case
                  Ignore case in searches that do not contain uppercase.
  -I  ........  --IGNORE-CASE
                  Ignore case in all searches.
  -j [_N]  ....  --jump-target=[_N]
                  Screen position of target lines.
  -J  ........  --status-column
                  Display a status column at left edge of screen.
  -k [_f_i_l_e]  .  --lesskey-file=[_f_i_l_e]
                  Use a lesskey file.
  -K  ........  --quit-on-intr
                  Exit less in response to ctrl-C.
  -L  ........  --no-lessopen
                  Ignore the LESSOPEN environment variable.
  -m  -M  ....  --long-prompt  --LONG-PROMPT
                  Set prompt style.
  -n  -N  ....  --line-numbers  --LINE-NUMBERS
                  Don't use line numbers.
  -o [_f_i_l_e]  .  --log-file=[_f_i_l_e]
                  Copy to log file (standard input only).
  -O [_f_i_l_e]  .  --LOG-FILE=[_f_i_l_e]
                  Copy to log file (unconditionally overwrite).
  -p [_p_a_t_t_e_r_n]  --pattern=[_p_a_t_t_e_r_n]
                  Start at pattern (from command line).
  -P [_p_r_o_m_p_t]   --prompt=[_p_r_o_m_p_t]
                  Define new prompt.
  -q  -Q  ....  --quiet  --QUIET  --silent --SILENT
                  Quiet the terminal bell.
  -r  -R  ....  --raw-control-chars  --RAW-CONTROL-CHARS
                  Output "raw" control characters.
  -s  ........  --squeeze-blank-lines
                  Squeeze multiple blank lines.
  -S  ........  --chop-long-lines
                  Chop (truncate) long lines rather than wrapping.
  -t [_t_a_g]  ..  --tag=[_t_a_g]
                  Find a tag.
  -T [_t_a_g_s_f_i_l_e] --tag-file=[_t_a_g_s_f_i_l_e]
                  Use an alternate tags file.
  -u  -U  ....  --underline-special  --UNDERLINE-SPECIAL
                  Change handling of backspaces.
  -V  ........  --version
                  Display the version number of "less".
  -w  ........  --hilite-unread
                  Highlight first new line after forward-screen.
  -W  ........  --HILITE-UNREAD
                  Highlight first new line after any forward movement.
  -x [_N[,...]]  --tabs=[_N[,...]]
                  Set tab stops.
  -X  ........  --no-init
                  Don't use termcap init/deinit strings.
  -y [_N]  ....  --max-forw-scroll=[_N]
                  Forward scroll limit.
  -z [_N]  ....  --window=[_N]
                  Set size of window.
  -" [_c[_c]]  .  --quotes=[_c[_c]]
                  Set shell quote characters.
  -~  ........  --tilde
                  Don't display tildes after end of file.
  -# [_N]  ....  --shift=[_N]
                  Set horizontal scroll amount (0 = one half screen width).
                --file-size
                  Automatically determine the size of the input file.
                --follow-name
                  The F command changes files if the input file is renamed.
                --incsearch
                  Search file as each pattern character is typed in.
                --line-num-width=N
                  Set the width of the -N line number field to N characters.
                --mouse
                  Enable mouse input.
                --no-keypad
                  Don't send termcap keypad init/deinit strings.
                --no-histdups
                  Remove duplicates from command history.
                --rscroll=C
                  Set the character used to mark truncated lines.
                --save-marks
                  Retain marks across invocations of less.
                --status-col-width=N
                  Set the width of the -J status column to N characters.
                --use-backslash
                  Subsequent options use backslash as escape char.
                --use-color
                  Enables colored text.
                --wheel-lines=N
                  Each click of the mouse wheel moves N lines.


 ---------------------------------------------------------------------------

                          LLIINNEE EEDDIITTIINNGG

        These keys can be used to edit text being entered 
        on the "command line" at the bottom of the screen.

 RightArrow ..................... ESC-l ... Move cursor right one character.
 LeftArrow ...................... ESC-h ... Move cursor left one character.
 ctrl-RightArrow  ESC-RightArrow  ESC-w ... Move cursor right one word.
 ctrl-LeftArrow   ESC-LeftArrow   ESC-b ... Move cursor left one word.
 HOME ........................... ESC-0 ... Move cursor to start of line.
 END ............................ ESC-$ ... Move cursor to end of line.
 BACKSPACE ................................ Delete char to left of cursor.
 DELETE ......................... ESC-x ... Delete char under cursor.
 ctrl-BACKSPACE   ESC-BACKSPACE ........... Delete word to left of cursor.
 ctrl-DELETE .... ESC-DELETE .... ESC-X ... Delete word under cursor.
 ctrl-U ......... ESC (MS-DOS only) ....... Delete entire line.
 UpArrow ........................ ESC-k ... Retrieve previous command line.
 DownArrow ...................... ESC-j ... Retrieve next command line.
 TAB ...................................... Complete filename & cycle.
 SHIFT-TAB ...................... ESC-TAB   Complete filename & reverse cycle.
 ctrl-L ................................... Complete filename, list all.
</file>

<file path="tomer = Customer.create!(">
=> [[32m#<ServiceType:0x00007f6ba4d66a70[0m
  id: [1;34m5[0m,
  name: [31m[1;31m"[0m[31mCompanion Care[1;31m"[0m[31m[0m,
  vertical_id: [1;34m2[0m,
  duration_minutes: [1;34m240[0m,
  requires_background_check: [1;36mtrue[0m,
  min_staff_ratio: [1;35m0.1e1[0m,
  created_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.159079000 +0000[1;31m"[0m[31m[0m,
  updated_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.159079000 +0000[1;31m"[0m[31m[0m[32m>[0m,
 [32m#<ServiceType:0x00007f6ba5307f88[0m
  id: [1;34m6[0m,
  name: [31m[1;31m"[0m[31mPersonal Care Assistance[1;31m"[0m[31m[0m,
  vertical_id: [1;34m2[0m,
  duration_minutes: [1;34m120[0m,
  requires_background_check: [1;36mtrue[0m,
  min_staff_ratio: [1;35m0.1e1[0m,
  created_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.180891000 +0000[1;31m"[0m[31m[0m,
  updated_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.180891000 +0000[1;31m"[0m[31m[0m[32m>[0m,
 [32m#<ServiceType:0x00007f6ba5307308[0m
  id: [1;34m7[0m,
  name: [31m[1;31m"[0m[31m24-Hour Care[1;31m"[0m[31m[0m,
  vertical_id: [1;34m2[0m,
  duration_minutes: [1;34m1440[0m,
  requires_background_check: [1;36mtrue[0m,
  min_staff_ratio: [1;35m0.2e1[0m,
  created_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.196416000 +0000[1;31m"[0m[31m[0m,
  updated_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.196416000 +0000[1;31m"[0m[31m[0m[32m>[0m,
 [32m#<ServiceType:0x00007f6ba5306408[0m
  id: [1;34m8[0m,
  name: [31m[1;31m"[0m[31mMedical Appointment Transport[1;31m"[0m[31m[0m,
  vertical_id: [1;34m2[0m,
  duration_minutes: [1;34m180[0m,
  requires_background_check: [1;36mtrue[0m,
  min_staff_ratio: [1;35m0.1e1[0m,
  created_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.224360000 +0000[1;31m"[0m[31m[0m,
  updated_at: [31m[1;31m"[0m[31m2025-08-31 22:57:36.224360000 +0000[1;31m"[0m[31m[0m[32m>[0m]
</file>

<file path="app/controllers/graphql_controller.rb">
# frozen_string_literal: true

class GraphqlController < ApplicationController
  # If accessing from outside this domain, nullify the session
  # This allows for outside API access while preventing CSRF attacks,
  # but you'll have to authenticate your user separately
  # protect_from_forgery with: :null_session

  def execute
    variables = prepare_variables(params[:variables])
    query = params[:query]
    operation_name = params[:operationName]
    context = {
      # Query context goes here, for example:
      # current_user: current_user,
    }
    result = CarestackSchema.execute(query, variables: variables, context: context, operation_name: operation_name)
    render json: result
  rescue StandardError => e
    raise e unless Rails.env.development?
    handle_error_in_development(e)
  end

  private

  # Handle variables in form data, JSON body, or a blank value
  def prepare_variables(variables_param)
    case variables_param
    when String
      if variables_param.present?
        JSON.parse(variables_param) || {}
      else
        {}
      end
    when Hash
      variables_param
    when ActionController::Parameters
      variables_param.to_unsafe_hash # GraphQL-Ruby will validate name and type of incoming variables.
    when nil
      {}
    else
      raise ArgumentError, "Unexpected parameter: #{variables_param}"
    end
  end

  def handle_error_in_development(e)
    logger.error e.message
    logger.error e.backtrace.join("\n")

    render json: { errors: [ { message: e.message, backtrace: e.backtrace } ], data: {} }, status: 500
  end
end
</file>

<file path="app/graphql/mutations/create_appointment.rb">
# frozen_string_literal: true

module Mutations
  class CreateAppointment < BaseMutation
    description "Create a new appointment with vertical-specific business rules"

    # Direct arguments (simpler approach)
    argument :account_id, ID, required: true
    argument :customer_id, ID, required: true
    argument :service_type_id, ID, required: true
    argument :staff_id, ID, required: true
    argument :scheduled_at, GraphQL::Types::ISO8601DateTime, required: true
    argument :notes, String, required: false

    # Return type
    field :appointment, Types::AppointmentType, null: true
    field :errors, [ String ], null: false

    def resolve(account_id:, customer_id:, service_type_id:, staff_id:, scheduled_at:, notes: nil)
      appointment = nil
      errors = []

      begin
        # Load all required records
        account = Account.find(account_id)
        customer = Customer.find(customer_id)
        service_type = ServiceType.find(service_type_id)
        staff = Staff.find(staff_id)

        # Validate business rules based on vertical
        validation_errors = validate_appointment_rules(account, service_type, staff)

        if validation_errors.any?
          return {
            appointment: nil,
            errors: validation_errors
          }
        end

        # Create the appointment
        appointment = Appointment.create!(
          account: account,
          customer: customer,
          service_type: service_type,
          staff: staff,
          scheduled_at: scheduled_at,
          duration_minutes: service_type.duration_minutes,
          status: "scheduled",
          notes: notes
        )

        {
          appointment: appointment,
          errors: []
        }

      rescue ActiveRecord::RecordNotFound => e
        {
          appointment: nil,
          errors: [ "Record not found: #{e.message}" ]
        }
      rescue ActiveRecord::RecordInvalid => e
        {
          appointment: nil,
          errors: e.record.errors.full_messages
        }
      rescue StandardError => e
        {
          appointment: nil,
          errors: [ "An error occurred: #{e.message}" ]
        }
      end
    end

    private

    def validate_appointment_rules(account, service_type, staff)
      errors = []

      # Verify service type belongs to account's vertical
      unless service_type.vertical == account.vertical
        errors << "Service type '#{service_type.name}' is not available for #{account.vertical.display_name} businesses"
      end

      # Verify staff belongs to the account
      unless staff.account == account
        errors << "Staff member does not belong to this account"
      end

      # Vertical-specific validations
      case account.vertical.slug
      when /cleaning/
        errors.concat(validate_cleaning_rules(account, service_type, staff))
      when /elderly_care/
        errors.concat(validate_elderly_care_rules(account, service_type, staff))
      end

      errors
    end

    def validate_cleaning_rules(account, service_type, staff)
      errors = []

      # For post-construction cleanup, require background check
      if service_type.requires_background_check && !staff.background_check_passed
        errors << "Staff member must have passed background check for '#{service_type.name}' service"
      end

      errors
    end

    def validate_elderly_care_rules(account, service_type, staff)
      errors = []

      # Elderly care always requires background checks
      unless staff.background_check_passed
        errors << "All elderly care staff must have passed background checks"
      end

      # Check minimum staff ratio requirements
      if service_type.min_staff_ratio.present? && service_type.min_staff_ratio > 1
        errors << "This service type requires #{service_type.min_staff_ratio} staff members minimum (multi-staff booking not yet implemented)"
      end

      errors
    end
  end
end
</file>

<file path="app/graphql/mutations/optimize_routes.rb">
# frozen_string_literal: true

module Mutations
  class OptimizeRoutes < BaseMutation
    description "Optimize routes for appointments on a given date using advanced algorithms"

    argument :account_id, ID, required: true
    argument :date, GraphQL::Types::ISO8601Date, required: true
    argument :optimization_type, String, required: false, default_value: "minimize_travel_time"
    argument :staff_ids, [ ID ], required: false
    argument :force_reoptimization, Boolean, required: false, default_value: false

    field :optimization_job, Types::OptimizationJobType, null: true
    field :routes, [ Types::RouteType ], null: true
    field :estimated_savings, Types::OptimizationSavingsType, null: true
    field :errors, [ String ], null: false

    def resolve(account_id:, date:, optimization_type: "minimize_travel_time", staff_ids: nil, force_reoptimization: false)
      begin
        account = Account.find(account_id)

        # Check if optimization already exists for this date
        existing_job = OptimizationJob.where(
          account: account,
          requested_date: date,
          status: "completed"
        ).order(created_at: :desc).first

        if existing_job && !force_reoptimization
          routes = Route.where(account: account, scheduled_date: date, status: "optimized")
          return {
            optimization_job: existing_job,
            routes: routes,
            estimated_savings: extract_savings_from_job(existing_job),
            errors: []
          }
        end

        # Validate optimization type
        valid_types = %w[minimize_travel_time minimize_total_cost balance_workload maximize_revenue]
        unless valid_types.include?(optimization_type)
          return {
            optimization_job: nil,
            routes: [],
            estimated_savings: nil,
            errors: [ "Invalid optimization type. Must be one of: #{valid_types.join(', ')}" ]
          }
        end

        # Check if there are appointments to optimize
        appointments = account.appointments
                             .where(scheduled_at: date.beginning_of_day..date.end_of_day)
                             .where(status: [ "scheduled", "confirmed" ])

        if staff_ids.present?
          appointments = appointments.where(staff_id: staff_ids)
        end

        if appointments.empty?
          return {
            optimization_job: nil,
            routes: [],
            estimated_savings: nil,
            errors: [ "No appointments found for optimization on #{date}" ]
          }
        end

        # Start route optimization
        optimizer = SimpleRouteOptimizerService.new(
          account_id: account.id,
          date: date,
          optimization_type: optimization_type,
          staff_ids: staff_ids || []
        )

        result = optimizer.optimize!

        if result[:success]
          {
            optimization_job: result[:optimization_job],
            routes: result[:routes],
            estimated_savings: build_savings_object(result[:metrics]),
            errors: []
          }
        else
          {
            optimization_job: result[:optimization_job],
            routes: [],
            estimated_savings: nil,
            errors: [ result[:error] ]
          }
        end

      rescue ActiveRecord::RecordNotFound => e
        {
          optimization_job: nil,
          routes: [],
          estimated_savings: nil,
          errors: [ "Record not found: #{e.message}" ]
        }
      rescue StandardError => e
        Rails.logger.error "Route optimization mutation failed: #{e.message}"
        Rails.logger.error e.backtrace.join("\n")

        {
          optimization_job: nil,
          routes: [],
          estimated_savings: nil,
          errors: [ "Optimization failed: #{e.message}" ]
        }
      end
    end

    private

    def extract_savings_from_job(job)
      return nil unless job.result

      OpenStruct.new(
        time_saved_hours: job.result["time_saved_hours"],
        cost_savings: job.result["cost_savings"],
        efficiency_improvement_percent: job.result["efficiency_improvement"],
        total_distance_km: job.result.dig("optimization_metrics", "total_distance_km"),
        routes_created: job.result["routes_created"]
      )
    end

    def build_savings_object(metrics)
      return nil unless metrics

      OpenStruct.new(
        time_saved_hours: metrics["time_saved_hours"],
        cost_savings: metrics["cost_savings"],
        efficiency_improvement_percent: metrics["efficiency_improvement"],
        total_distance_km: metrics["total_distance_km"],
        routes_created: metrics["routes_created"]
      )
    end
  end
end
</file>

<file path="app/graphql/types/optimization_job_type.rb">
# frozen_string_literal: true

module Types
  class OptimizationJobType < Types::BaseObject
    field :id, ID, null: false
    field :requested_date, GraphQL::Types::ISO8601Date, null: false
    field :status, String, null: false
    field :parameters, GraphQL::Types::JSON, null: true
    field :result, GraphQL::Types::JSON, null: true
    field :processing_started_at, GraphQL::Types::ISO8601DateTime, null: true
    field :processing_completed_at, GraphQL::Types::ISO8601DateTime, null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :account, Types::AccountType, null: false

    # Computed fields
    field :processing_time_seconds, Integer, null: true
    field :success, Boolean, null: false
    field :failed, Boolean, null: false
    field :processing, Boolean, null: false
    field :time_savings_hours, Float, null: true
    field :cost_savings, Float, null: true
    field :routes_created, Integer, null: false

    def processing_time_seconds
      object.processing_time_seconds&.to_i
    end

    def success
      object.success?
    end

    def failed
      object.failed?
    end

    def processing
      object.processing?
    end

    def time_savings_hours
      object.time_savings
    end

    def cost_savings
      object.cost_savings
    end
  end
end
</file>

<file path="app/graphql/types/optimization_savings_type.rb">
# frozen_string_literal: true

module Types
  class OptimizationSavingsType < Types::BaseObject
    field :time_saved_hours, Float, null: true
    field :cost_savings, Float, null: true
    field :efficiency_improvement_percent, Float, null: true
    field :total_distance_km, Float, null: true
    field :routes_created, Integer, null: true
  end
end
</file>

<file path="app/graphql/types/query_type.rb">
# frozen_string_literal: true

module Types
  class QueryType < Types::BaseObject
    include GraphQL::Types::Relay::HasNodeField
    include GraphQL::Types::Relay::HasNodesField

    # Add root-level fields type by type.

    field :node, Types::NodeType, null: true, description: "Fetches an object given its ID." do
      argument :id, GraphQL::Types::ID, required: true, description: "ID of the object."
    end

    def node(id:)
      context.schema.object_from_id(id, context)
    end

    field :nodes, [ Types::NodeType, null: true ], null: true, description: "Fetches a list of objects given a list of IDs." do
      argument :ids, [ GraphQL::Types::ID ], required: true, description: "IDs of the objects."
    end

    def nodes(ids:)
      ids.map { |id| context.schema.object_from_id(id, context) }
    end

    # Our custom fields
    field :verticals, [ Types::VerticalType ], null: false, description: "Get all available verticals"
    field :vertical, Types::VerticalType, null: true, description: "Get a specific vertical" do
      argument :id, GraphQL::Types::ID, required: false
      argument :slug, String, required: false
    end

    field :accounts, [ Types::AccountType ], null: false, description: "Get all accounts"
    field :account, Types::AccountType, null: true, description: "Get a specific account" do
      argument :id, GraphQL::Types::ID, required: true
    end

    field :service_types, [ Types::ServiceType ], null: false, description: "Get all service types"
    field :service_types_for_vertical, [ Types::ServiceType ], null: false, description: "Get service types for a specific vertical" do
      argument :vertical_id, GraphQL::Types::ID, required: true
    end

    # Resolver methods
    def verticals
      Vertical.active
    end

    def vertical(id: nil, slug: nil)
      if id
        Vertical.find_by(id: id)
      elsif slug
        Vertical.find_by(slug: slug)
      else
        raise GraphQL::ExecutionError, "Must provide either id or slug"
      end
    end

    def accounts
      Account.all
    end

    def account(id:)
      Account.find_by(id: id)
    end

    def service_types
      ServiceType.all
    end

    def service_types_for_vertical(vertical_id:)
      ServiceType.where(vertical_id: vertical_id)
    end
  end
end
</file>

<file path="app/graphql/types/route_stop_type.rb">
# frozen_string_literal: true

module Types
  class RouteStopType < Types::BaseObject
    field :id, ID, null: false
    field :stop_order, Integer, null: false
    field :estimated_arrival, GraphQL::Types::ISO8601DateTime, null: false
    field :estimated_departure, GraphQL::Types::ISO8601DateTime, null: true
    field :actual_arrival, GraphQL::Types::ISO8601DateTime, null: true
    field :actual_departure, GraphQL::Types::ISO8601DateTime, null: true

    # Associations
    field :route, Types::RouteType, null: false
    field :appointment, Types::AppointmentType, null: false

    # Computed fields
    field :service_duration_minutes, Integer, null: false
    field :buffer_time_minutes, Integer, null: true
    field :on_time, Boolean, null: true
    field :delayed, Boolean, null: false
    field :delay_minutes, Integer, null: false

    def service_duration_minutes
      object.appointment.service_type.duration_minutes
    end

    def buffer_time_minutes
      buffer_seconds = object.buffer_time
      buffer_seconds ? (buffer_seconds / 60).round : nil
    end

    def on_time
      object.on_time?
    end

    def delayed
      object.delayed?
    end
  end
end
</file>

<file path="app/graphql/types/route_type.rb">
# frozen_string_literal: true

module Types
  class RouteType < Types::BaseObject
    field :id, ID, null: false
    field :scheduled_date, GraphQL::Types::ISO8601Date, null: false
    field :status, String, null: false
    field :total_distance_meters, Integer, null: false
    field :total_duration_seconds, Integer, null: false
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :account, Types::AccountType, null: false
    field :route_stops, [ Types::RouteStopType ], null: false
    field :appointments, [ Types::AppointmentType ], null: false

    # Computed fields
    field :total_distance_km, Float, null: false
    field :total_duration_hours, Float, null: false
    field :estimated_fuel_cost, Float, null: false do
      argument :cost_per_km, Float, required: false, default_value: 0.15
    end
    field :staff_member, Types::StaffType, null: true

    def estimated_fuel_cost(cost_per_km:)
      object.estimated_fuel_cost(cost_per_km)
    end
  end
end
</file>

<file path="app/graphql/types/service_type.rb">
# frozen_string_literal: true

module Types
  class ServiceType < Types::BaseObject
    field :id, ID, null: false
    field :name, String, null: false
    field :duration_minutes, Integer, null: false
    field :requires_background_check, Boolean, null: false
    field :min_staff_ratio, Float, null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :vertical, Types::VerticalType, null: false

    # Business logic fields
    field :display_name, String, null: false
    field :duration_in_hours, String, null: false
    field :estimated_cost, Float, null: false do
      argument :hourly_rate, Float, required: false, default_value: 50.0
    end
    field :requires_multiple_staff, Boolean, null: false
    field :compliance_requirements, [ String ], null: false

    # Delegated methods
    def estimated_cost(hourly_rate:)
      object.estimated_cost(hourly_rate)
    end
  end
end
</file>

<file path="app/graphql/types/vertical_type.rb">
# frozen_string_literal: true

module Types
  class VerticalType < Types::BaseObject
    field :id, ID, null: false
    field :name, String, null: false
    field :slug, String, null: false
    field :description, String, null: true
    field :active, Boolean, null: false
    field :display_name, String, null: false
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :accounts, [ Types::AccountType ], null: false
    field :service_types, [ Types::ServiceType ], null: false

    # Business logic fields
    field :is_cleaning, Boolean, null: false
    field :is_elderly_care, Boolean, null: false
    field :requires_compliance_tracking, Boolean, null: false
    field :requires_background_checks, Boolean, null: false

    # Computed fields
    field :total_accounts, Integer, null: false
    field :total_service_types, Integer, null: false

    def is_cleaning
      object.cleaning?
    end

    def is_elderly_care
      object.elderly_care?
    end

    def requires_compliance_tracking
      object.requires_compliance_tracking?
    end

    def requires_background_checks
      object.requires_background_checks?
    end

    def total_accounts
      object.accounts.count
    end

    def total_service_types
      object.service_types.count
    end
  end
end
</file>

<file path="app/models/account.rb">
class Account < ApplicationRecord
  # Relationships
  belongs_to :vertical
  has_many :customers, dependent: :destroy
  has_many :staff, dependent: :destroy
  has_many :appointments, dependent: :destroy
  has_many :service_types, through: :vertical

  # Validations
  validates :name, presence: true
  validates :email, presence: true, format: { with: URI::MailTo::EMAIL_REGEXP }
  validates :phone, presence: true

  # Delegations to vertical for cleaner code
  delegate :display_name, to: :vertical, prefix: true
  delegate :requires_compliance_tracking?, to: :vertical
  delegate :requires_background_checks?, to: :vertical
  delegate :cleaning?, to: :vertical
  delegate :elderly_care?, to: :vertical

  # Scopes
  scope :for_vertical, ->(vertical_slug) { joins(:vertical).where(verticals: { slug: vertical_slug }) }
  scope :cleaning_services, -> { for_vertical("cleaning") }
  scope :elderly_care_services, -> { for_vertical("elderly_care") }

  # Instance methods
  def display_name_with_vertical
    "#{name} (#{vertical_display_name})"
  end

  def total_customers
    customers.count
  end

  def total_staff
    staff.count
  end

  def active_appointments
    appointments.where(status: [ "scheduled", "in_progress" ])
  end

  def completed_appointments_this_month
    appointments.where(
      status: "completed",
      scheduled_at: 1.month.ago.beginning_of_month..Time.current
    )
  end

  # Vertical-specific business rules
  def can_schedule_appointment?(service_type, staff_count)
    return false unless service_type.vertical == vertical

    if requires_background_checks?
      return false unless all_staff_background_checked?
    end

    if elderly_care? && service_type.min_staff_ratio.present?
      return staff_count >= service_type.min_staff_ratio
    end

    true
  end

  def compliance_status
    return :not_required unless requires_compliance_tracking?

    if elderly_care?
      {
        background_checks: staff.where(background_check_passed: true).count,
        total_staff: staff.count,
        compliance_rate: calculate_compliance_rate
      }
    end
  end

  private

  def all_staff_background_checked?
    staff.where(background_check_passed: false).count == 0
  end

  def calculate_compliance_rate
    return 0.0 if staff.count == 0

    (staff.where(background_check_passed: true).count.to_f / staff.count * 100).round(2)
  end
end
</file>

<file path="app/models/optimization_job.rb">
class OptimizationJob < ApplicationRecord
  belongs_to :account

  validates :requested_date, presence: true
  validates :status, presence: true, inclusion: { in: %w[pending processing completed failed] }

  scope :recent, -> { where(created_at: 1.week.ago..) }
  scope :for_date, ->(date) { where(requested_date: date) }

  def processing_time_seconds
    return nil unless processing_started_at && processing_completed_at

    processing_completed_at - processing_started_at
  end

  def success?
    status == "completed"
  end

  def failed?
    status == "failed"
  end

  def processing?
    status == "processing"
  end

  def time_savings
    return nil unless success? && result&.dig("time_saved_hours")

    result["time_saved_hours"]
  end

  def cost_savings
    return nil unless success? && result&.dig("cost_savings")

    result["cost_savings"]
  end

  def routes_created
    return 0 unless success? && result&.dig("routes_created")

    result["routes_created"]
  end
end
</file>

<file path="app/models/route_stop.rb">
class RouteStop < ApplicationRecord
  belongs_to :route
  belongs_to :appointment

  validates :stop_order, presence: true, uniqueness: { scope: :route_id }
  validates :estimated_arrival, presence: true

  scope :ordered, -> { order(:stop_order) }

  def duration_at_stop
    return 0 if estimated_departure.blank? || estimated_arrival.blank?

    estimated_departure - estimated_arrival
  end

  def service_duration
    appointment.service_type.duration_minutes * 60
  end

  def buffer_time
    duration_at_stop - service_duration
  end

  def on_time?
    return nil if actual_arrival.blank? || estimated_arrival.blank?

    (actual_arrival - estimated_arrival).abs < 15.minutes
  end

  def delayed?
    return false if actual_arrival.blank? || estimated_arrival.blank?

    actual_arrival > estimated_arrival + 15.minutes
  end

  def delay_minutes
    return 0 if actual_arrival.blank? || estimated_arrival.blank?

    [ (actual_arrival - estimated_arrival) / 60, 0 ].max.round
  end
end
</file>

<file path="app/models/route.rb">
class Route < ApplicationRecord
  belongs_to :account
  has_many :route_stops, dependent: :destroy
  has_many :appointments, through: :route_stops

  validates :scheduled_date, presence: true
  validates :status, presence: true, inclusion: { in: %w[pending optimized active completed cancelled] }

  scope :for_date, ->(date) { where(scheduled_date: date) }
  scope :active, -> { where(status: %w[optimized active]) }

  def total_distance_km
    total_distance_meters / 1000.0
  end

  def total_duration_hours
    total_duration_seconds / 3600.0
  end

  def estimated_fuel_cost(cost_per_km = 0.15)
    total_distance_km * cost_per_km
  end

  def staff_member
    # Assuming one staff per route - could be enhanced for multi-staff routes
    route_stops.joins(:appointment).first&.appointment&.staff
  end
end
</file>

<file path="app/models/service_type.rb">
class ServiceType < ApplicationRecord
  # Relationships
  belongs_to :vertical
  has_many :appointments, dependent: :destroy

  # Validations
  validates :name, presence: true
  validates :duration_minutes, presence: true, numericality: { greater_than: 0 }
  validates :min_staff_ratio, numericality: { greater_than: 0 }, allow_nil: true

  # Scopes
  scope :requiring_background_check, -> { where(requires_background_check: true) }
  scope :for_vertical, ->(vertical_slug) { joins(:vertical).where(verticals: { slug: vertical_slug }) }

  # Delegations
  delegate :cleaning?, :elderly_care?, :requires_compliance_tracking?, to: :vertical

  # Instance methods
  def display_name
    "#{name} (#{duration_in_hours})"
  end

  def duration_in_hours
    hours = duration_minutes / 60.0
    if hours == hours.to_i
      "#{hours.to_i}h"
    else
      "#{hours}h"
    end
  end

  def estimated_cost(hourly_rate = 50.0)
    (duration_minutes / 60.0 * hourly_rate).round(2)
  end

  def requires_multiple_staff?
    min_staff_ratio.present? && min_staff_ratio > 1
  end

  def compliance_requirements
    requirements = []

    requirements << "Background check required" if requires_background_check?
    requirements << "Minimum #{min_staff_ratio} staff members" if requires_multiple_staff?
    requirements << "Compliance tracking enabled" if requires_compliance_tracking?

    requirements
  end

  # Class methods for creating default service types
  def self.create_defaults_for_vertical(vertical)
    case vertical.slug
    when /cleaning/
      create_cleaning_defaults(vertical)
    when /elderly_care/
      create_elderly_care_defaults(vertical)
    when /tutoring/
      create_tutoring_defaults(vertical)
    end
  end

  private

  def self.create_cleaning_defaults(vertical)
    [
      { name: "Basic House Cleaning", duration_minutes: 120, requires_background_check: false },
      { name: "Deep Cleaning", duration_minutes: 240, requires_background_check: false },
      { name: "Move-in/Move-out Cleaning", duration_minutes: 180, requires_background_check: false },
      { name: "Post-Construction Cleanup", duration_minutes: 300, requires_background_check: true }
    ].each do |attrs|
      vertical.service_types.find_or_create_by(name: attrs[:name]) do |service_type|
        service_type.assign_attributes(attrs)
      end
    end
  end

  def self.create_elderly_care_defaults(vertical)
    [
      {
        name: "Companion Care",
        duration_minutes: 240,
        requires_background_check: true,
        min_staff_ratio: 1.0
      },
      {
        name: "Personal Care Assistance",
        duration_minutes: 120,
        requires_background_check: true,
        min_staff_ratio: 1.0
      },
      {
        name: "24-Hour Care",
        duration_minutes: 1440,
        requires_background_check: true,
        min_staff_ratio: 2.0
      },
      {
        name: "Medical Appointment Transport",
        duration_minutes: 180,
        requires_background_check: true,
        min_staff_ratio: 1.0
      }
    ].each do |attrs|
      vertical.service_types.find_or_create_by(name: attrs[:name]) do |service_type|
        service_type.assign_attributes(attrs)
      end
    end
  end

  def self.create_tutoring_defaults(vertical)
    [
      { name: "Elementary Tutoring", duration_minutes: 60, requires_background_check: true },
      { name: "High School Math", duration_minutes: 90, requires_background_check: true },
      { name: "Test Prep (SAT/ACT)", duration_minutes: 120, requires_background_check: true },
      { name: "College Application Help", duration_minutes: 90, requires_background_check: true }
    ].each do |attrs|
      vertical.service_types.find_or_create_by(name: attrs[:name]) do |service_type|
        service_type.assign_attributes(attrs)
      end
    end
  end
end
</file>

<file path="app/services/google_maps_service.rb">
# frozen_string_literal: true

class GoogleMapsService
  include HTTParty

  base_uri "https://maps.googleapis.com/maps/api"

  def initialize
    @api_key = Rails.application.credentials.google_maps_api_key
    raise "Google Maps API key not configured" if @api_key.blank?
  end

  def geocode(address)
    return nil if address.blank?

    Rails.cache.fetch("geocode:#{address}", expires_in: 30.days) do
      response = self.class.get("/geocode/json", {
        query: {
          address: address,
          key: @api_key
        }
      })

      if response.success? && response["status"] == "OK"
        result = response["results"].first
        {
          lat: result["geometry"]["location"]["lat"],
          lng: result["geometry"]["location"]["lng"],
          formatted_address: result["formatted_address"],
          place_id: result["place_id"]
        }
      else
        Rails.logger.warn "Geocoding failed for address '#{address}': #{response['status']}"
        nil
      end
    end
  end

  def distance_matrix(locations)
    return {} if locations.empty?

    # Split into manageable chunks (Google Maps API limit is 25 origins x 25 destinations)
    chunks = locations.each_slice(20).to_a
    distance_data = {}

    chunks.each do |origin_chunk|
      chunks.each do |destination_chunk|
        origins = origin_chunk.map { |loc| "#{loc[:lat]},#{loc[:lng]}" }.join("|")
        destinations = destination_chunk.map { |loc| "#{loc[:lat]},#{loc[:lng]}" }.join("|")

        cache_key = "distance_matrix:#{Digest::MD5.hexdigest("#{origins}:#{destinations}")}"

        chunk_data = Rails.cache.fetch(cache_key, expires_in: 4.hours) do
          response = self.class.get("/distancematrix/json", {
            query: {
              origins: origins,
              destinations: destinations,
              key: @api_key,
              mode: "driving",
              departure_time: "now",
              traffic_model: "best_guess",
              units: "metric"
            }
          })

          if response.success? && response["status"] == "OK"
            parse_distance_matrix_response(response, origin_chunk, destination_chunk)
          else
            Rails.logger.error "Distance matrix API failed: #{response['status']}"
            {}
          end
        end

        distance_data.merge!(chunk_data)
      end
    end

    distance_data
  end

  def directions(origin, destination, waypoints = [])
    waypoint_string = waypoints.any? ? waypoints.map { |w| "#{w[:lat]},#{w[:lng]}" }.join("|") : nil

    response = self.class.get("/directions/json", {
      query: {
        origin: "#{origin[:lat]},#{origin[:lng]}",
        destination: "#{destination[:lat]},#{destination[:lng]}",
        waypoints: waypoint_string,
        optimize: waypoints.any?,
        key: @api_key,
        mode: "driving",
        departure_time: "now",
        traffic_model: "best_guess"
      }.compact
    })

    if response.success? && response["status"] == "OK"
      parse_directions_response(response)
    else
      Rails.logger.error "Directions API failed: #{response['status']}"
      nil
    end
  end

  def traffic_factor(origin, destination, departure_time = Time.current)
    # Get both current traffic and free-flow time
    queries = [
      { departure_time: "now", traffic_model: "best_guess" },
      { traffic_model: "optimistic" }
    ]

    results = queries.map do |query_params|
      response = self.class.get("/distancematrix/json", {
        query: {
          origins: "#{origin[:lat]},#{origin[:lng]}",
          destinations: "#{destination[:lat]},#{destination[:lng]}",
          key: @api_key,
          mode: "driving",
          units: "metric"
        }.merge(query_params)
      })

      if response.success? && response["status"] == "OK"
        element = response["rows"].first["elements"].first
        element["duration"]["value"] if element["status"] == "OK"
      end
    end

    traffic_duration, free_flow_duration = results

    if traffic_duration && free_flow_duration && free_flow_duration > 0
      (traffic_duration.to_f / free_flow_duration).round(2)
    else
      1.0 # Default to no traffic impact
    end
  end

  private

  def parse_distance_matrix_response(response, origins, destinations)
    data = {}

    response["rows"].each_with_index do |row, origin_index|
      origin_location = origins[origin_index]

      row["elements"].each_with_index do |element, dest_index|
        destination_location = destinations[dest_index]

        if element["status"] == "OK"
          key = "#{origin_location[:id]}:#{destination_location[:id]}"
          data[key] = {
            distance_meters: element["distance"]["value"],
            duration_seconds: element["duration"]["value"],
            duration_in_traffic_seconds: element.dig("duration_in_traffic", "value"),
            from_location: origin_location,
            to_location: destination_location
          }
        end
      end
    end

    data
  end

  def parse_directions_response(response)
    route = response["routes"].first
    return nil unless route

    legs = route["legs"].map do |leg|
      {
        start_location: leg["start_location"],
        end_location: leg["end_location"],
        distance_meters: leg["distance"]["value"],
        duration_seconds: leg["duration"]["value"],
        duration_in_traffic_seconds: leg.dig("duration_in_traffic", "value"),
        steps: leg["steps"].map do |step|
          {
            distance_meters: step["distance"]["value"],
            duration_seconds: step["duration"]["value"],
            instructions: step["html_instructions"],
            maneuver: step["maneuver"]
          }
        end
      }
    end

    {
      overview_polyline: route["overview_polyline"]["points"],
      total_distance_meters: legs.sum { |leg| leg[:distance_meters] },
      total_duration_seconds: legs.sum { |leg| leg[:duration_seconds] },
      legs: legs,
      waypoint_order: route["waypoint_order"]
    }
  end
end
</file>

<file path="app/services/mock_google_map_service.rb">
# frozen_string_literal: true

# Mock service for development/testing without Google Maps API
class MockGoogleMapsService
  def geocode(address)
    # Mock geocoding for Edmonton area
    case address.downcase
    when /downtown/
      { lat: 53.5461, lng: -113.4938, formatted_address: "Downtown Edmonton, AB, Canada" }
    when /west/
      { lat: 53.5232, lng: -113.5263, formatted_address: "West Edmonton, AB, Canada" }
    when /north/
      { lat: 53.5731, lng: -113.4903, formatted_address: "North Edmonton, AB, Canada" }
    when /south/
      { lat: 53.4668, lng: -113.5114, formatted_address: "South Edmonton, AB, Canada" }
    when /east/
      { lat: 53.5586, lng: -113.4086, formatted_address: "East Edmonton, AB, Canada" }
    else
      # Random Edmonton area coordinates
      {
        lat: 53.5 + rand(0.2),
        lng: -113.5 + rand(0.2),
        formatted_address: "#{address}, Edmonton, AB, Canada"
      }
    end
  end

  def distance_matrix(locations)
    distance_data = {}

    locations.each do |from_location|
      locations.each do |to_location|
        next if from_location[:id] == to_location[:id]

        # Calculate approximate distance using Haversine formula
        distance_meters = haversine_distance(
          from_location[:lat], from_location[:lng],
          to_location[:lat], to_location[:lng]
        )

        # Estimate driving time (assuming 40 km/h average in city)
        duration_seconds = (distance_meters / 1000.0 / 40.0 * 3600).to_i

        key = "#{from_location[:id]}:#{to_location[:id]}"
        distance_data[key] = {
          distance_meters: distance_meters.to_i,
          duration_seconds: duration_seconds,
          duration_in_traffic_seconds: (duration_seconds * (1.0 + rand(0.5))).to_i, # Add random traffic
          from_location: from_location,
          to_location: to_location
        }
      end
    end

    distance_data
  end

  private

  def haversine_distance(lat1, lon1, lat2, lon2)
    # Earth's radius in meters
    r = 6_371_000

    # Convert degrees to radians
    lat1_rad = lat1 * Math::PI / 180
    lat2_rad = lat2 * Math::PI / 180
    delta_lat = (lat2 - lat1) * Math::PI / 180
    delta_lon = (lon2 - lon1) * Math::PI / 180

    # Haversine formula
    a = Math.sin(delta_lat/2) * Math.sin(delta_lat/2) +
        Math.cos(lat1_rad) * Math.cos(lat2_rad) *
        Math.sin(delta_lon/2) * Math.sin(delta_lon/2)

    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))

    r * c
  end
end
</file>

<file path="app/services/mock_google_maps_service.rb">
# frozen_string_literal: true

# Mock service for development/testing without Google Maps API
class MockGoogleMapsService
  def geocode(address)
    # Mock geocoding for Edmonton area
    case address.downcase
    when /downtown/
      { lat: 53.5461, lng: -113.4938, formatted_address: "Downtown Edmonton, AB, Canada" }
    when /west/
      { lat: 53.5232, lng: -113.5263, formatted_address: "West Edmonton, AB, Canada" }
    when /north/
      { lat: 53.5731, lng: -113.4903, formatted_address: "North Edmonton, AB, Canada" }
    when /south/
      { lat: 53.4668, lng: -113.5114, formatted_address: "South Edmonton, AB, Canada" }
    when /east/
      { lat: 53.5586, lng: -113.4086, formatted_address: "East Edmonton, AB, Canada" }
    else
      # Random Edmonton area coordinates
      {
        lat: 53.5 + rand(0.2),
        lng: -113.5 + rand(0.2),
        formatted_address: "#{address}, Edmonton, AB, Canada"
      }
    end
  end

  def distance_matrix(locations)
    distance_data = {}

    locations.each do |from_location|
      locations.each do |to_location|
        next if from_location[:id] == to_location[:id]

        # Calculate approximate distance using Haversine formula
        distance_meters = haversine_distance(
          from_location[:lat], from_location[:lng],
          to_location[:lat], to_location[:lng]
        )

        # Estimate driving time (assuming 40 km/h average in city)
        duration_seconds = (distance_meters / 1000.0 / 40.0 * 3600).to_i

        key = "#{from_location[:id]}:#{to_location[:id]}"
        distance_data[key] = {
          distance_meters: distance_meters.to_i,
          duration_seconds: duration_seconds,
          duration_in_traffic_seconds: (duration_seconds * (1.0 + rand(0.5))).to_i, # Add random traffic
          from_location: from_location,
          to_location: to_location
        }
      end
    end

    distance_data
  end

  private

  def haversine_distance(lat1, lon1, lat2, lon2)
    # Earth's radius in meters
    r = 6_371_000

    # Convert degrees to radians
    lat1_rad = lat1 * Math::PI / 180
    lat2_rad = lat2 * Math::PI / 180
    delta_lat = (lat2 - lat1) * Math::PI / 180
    delta_lon = (lon2 - lon1) * Math::PI / 180

    # Haversine formula
    a = Math.sin(delta_lat/2) * Math.sin(delta_lat/2) +
        Math.cos(lat1_rad) * Math.cos(lat2_rad) *
        Math.sin(delta_lon/2) * Math.sin(delta_lon/2)

    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))

    r * c
  end
end
</file>

<file path="app/services/route_optimzer_service.rb">
# frozen_string_literal: true

class RouteOptimizerService
  include ActiveModel::Model
  include ActiveModel::Attributes

  attribute :account_id, :integer
  attribute :date, :date
  attribute :optimization_type, :string, default: "minimize_travel_time"
  attribute :max_processing_time_seconds, :integer, default: 30
  attribute :staff_ids, :array, default: []

  OPTIMIZATION_TYPES = %w[
    minimize_travel_time
    minimize_total_cost
    balance_workload
    maximize_revenue
  ].freeze

  def initialize(attributes = {})
    super
    @account = Account.find(account_id)
    @appointments = load_appointments
    @staff_members = load_staff_members
    @optimization_job = create_optimization_job
  end

  def optimize!
    # Use simplified optimizer for now
    simple_optimizer = SimpleRouteOptimizerService.new(
      account_id: account_id,
      date: date,
      optimization_type: optimization_type,
      staff_ids: staff_ids
    )

    simple_optimizer.optimize!
  end

  private

  def load_appointments
    scope = @account.appointments
                   .where(scheduled_at: date.beginning_of_day..date.end_of_day)
                   .where(status: [ "scheduled", "confirmed" ])
                   .includes(:customer, :service_type, :staff)

    scope = scope.where(staff_id: staff_ids) if staff_ids.present?
    scope.to_a
  end

  def load_staff_members
    scope = @account.staff.where(id: @appointments.map(&:staff_id).compact.uniq)
    scope = scope.where(id: staff_ids) if staff_ids.present?
    scope.to_a
  end

  def create_optimization_job
    OptimizationJob.create!(
      account: @account,
      requested_date: date,
      status: "pending",
      parameters: {
        optimization_type: optimization_type,
        appointment_count: @appointments.count,
        staff_count: @staff_members.count,
        max_processing_time: max_processing_time_seconds
      }
    )
  end

  def geocode_missing_locations!
    customers_to_geocode = @appointments.map(&:customer)
                                      .select { |c| c.latitude.blank? || c.longitude.blank? }
                                      .uniq

    customers_to_geocode.each do |customer|
      coordinates = GoogleMapsService.new.geocode(customer.address)
      if coordinates
        customer.update!(
          latitude: coordinates[:lat],
          longitude: coordinates[:lng],
          geocoded_address: coordinates[:formatted_address]
        )
      end
    end
  end

  def calculate_distance_matrix
    locations = @appointments.map { |apt|
      {
        id: apt.id,
        lat: apt.customer.latitude,
        lng: apt.customer.longitude,
        staff_id: apt.staff_id,
        duration_minutes: apt.service_type.duration_minutes,
        revenue: apt.service_type.estimated_cost(hourly_rate_for_staff(apt.staff))
      }
    }

    # Add staff home locations as starting points
    @staff_members.each do |staff|
      locations << {
        id: "staff_home_#{staff.id}",
        lat: staff.home_latitude || @account.vertical.default_lat,
        lng: staff.home_longitude || @account.vertical.default_lng,
        staff_id: staff.id,
        duration_minutes: 0,
        revenue: 0,
        is_start_location: true
      }
    end

    GoogleMapsService.new.distance_matrix(locations)
  end

  def minimize_travel_time(distance_matrix)
    # Genetic Algorithm approach for Vehicle Routing Problem with Time Windows
    algorithm = GeneticVRPSolver.new(
      distance_matrix: distance_matrix,
      appointments: @appointments,
      staff_members: @staff_members,
      objective: :minimize_time,
      max_iterations: 1000,
      population_size: 100
    )

    algorithm.solve
  end

  def balance_workload(distance_matrix)
    # Balanced assignment ensuring fair distribution
    WorkloadBalancer.new(
      distance_matrix: distance_matrix,
      appointments: @appointments,
      staff_members: @staff_members
    ).optimize
  end

  def maximize_revenue(distance_matrix)
    # Prioritize high-value appointments while minimizing travel
    RevenueMaximizer.new(
      distance_matrix: distance_matrix,
      appointments: @appointments,
      staff_members: @staff_members
    ).optimize
  end

  def minimize_total_cost(distance_matrix)
    # Balance travel costs with opportunity costs
    CostMinimizer.new(
      distance_matrix: distance_matrix,
      appointments: @appointments,
      staff_members: @staff_members,
      fuel_cost_per_km: 0.15,
      hourly_wage_rates: calculate_wage_rates
    ).optimize
  end

  def create_route_records(optimized_routes)
    routes = []

    optimized_routes.each do |route_data|
      route = Route.create!(
        account: @account,
        scheduled_date: date,
        status: "optimized",
        total_distance_meters: route_data[:total_distance],
        total_duration_seconds: route_data[:total_duration]
      )

      route_data[:stops].each_with_index do |stop, index|
        RouteStop.create!(
          route: route,
          appointment_id: stop[:appointment_id],
          stop_order: index,
          estimated_arrival: stop[:estimated_arrival],
          estimated_departure: stop[:estimated_departure]
        )
      end

      routes << route
    end

    routes
  end

  def update_appointment_assignments(routes)
    routes.each do |route|
      route.route_stops.includes(:appointment).each do |stop|
        stop.appointment.update!(
          staff_id: route_staff_assignment[route.id],
          scheduled_at: stop.estimated_arrival
        )
      end
    end
  end

  def calculate_savings(routes)
    # Compare against baseline random assignment
    baseline_travel_time = estimate_baseline_travel_time
    optimized_travel_time = routes.sum(&:total_duration_seconds)

    time_saved_hours = (baseline_travel_time - optimized_travel_time) / 3600.0
    cost_per_hour = 25.0 # Average staff cost per hour

    {
      time_saved_hours: time_saved_hours.round(2),
      cost_savings: (time_saved_hours * cost_per_hour).round(2),
      efficiency_improvement: ((time_saved_hours / (baseline_travel_time / 3600.0)) * 100).round(2)
    }
  end

  def calculate_metrics(routes)
    {
      total_routes: routes.count,
      average_route_duration: routes.average(:total_duration_seconds),
      total_distance_km: routes.sum(:total_distance_meters) / 1000.0,
      appointments_per_route: (@appointments.count / routes.count.to_f).round(2)
    }
  end

  def hourly_rate_for_staff(staff)
    # Default rate logic - could be customized per staff/vertical
    case @account.vertical.slug
    when /cleaning/
      50.0
    when /elderly_care/
      65.0
    else
      55.0
    end
  end

  def update_job_status(status, result_data = {})
    @optimization_job.update!(
      status: status,
      result: result_data,
      processing_completed_at: (status.in?([ "completed", "failed" ]) ? Time.current : nil)
    )
  end

  def success_result(routes)
    {
      success: true,
      routes: routes,
      optimization_job: @optimization_job,
      metrics: @optimization_job.result
    }
  end

  def failed_result(error_message)
    {
      success: false,
      error: error_message,
      optimization_job: @optimization_job
    }
  end

  def estimate_baseline_travel_time
    # Rough estimate of random assignment travel time
    @appointments.count * 1800 # 30 minutes average travel between jobs
  end

  def calculate_wage_rates
    @staff_members.map { |staff| [ staff.id, hourly_rate_for_staff(staff) ] }.to_h
  end

  def route_staff_assignment
    @route_staff_assignment ||= {}
  end
end
</file>

<file path="app/services/simple_route_optimizer_service.rb">
# frozen_string_literal: true

class SimpleRouteOptimizerService
  def initialize(account_id:, date:, optimization_type: "minimize_travel_time", staff_ids: [])
    @account = Account.find(account_id)
    @date = date
    @optimization_type = optimization_type
    @staff_ids = staff_ids
    @appointments = load_appointments
    @staff_members = load_staff_members
    @maps_service = MockGoogleMapsService.new
  end

  def optimize!
    return failed_result("No appointments to optimize") if @appointments.empty?
    return failed_result("No available staff") if @staff_members.empty?

    begin
      # Create optimization job record
      job = OptimizationJob.create!(
        account: @account,
        requested_date: @date,
        status: "processing",
        parameters: {
          optimization_type: @optimization_type,
          appointment_count: @appointments.count,
          staff_count: @staff_members.count
        },
        processing_started_at: Time.current
      )

      # Build location data
      locations = build_location_data

      # Get distance matrix
      distance_matrix = @maps_service.distance_matrix(locations)

      # Create optimized routes using simple nearest neighbor algorithm
      optimized_routes = create_optimized_routes(distance_matrix)

      # Save routes to database
      saved_routes = save_routes_to_database(optimized_routes)

      # Calculate savings
      savings = calculate_savings(saved_routes, distance_matrix)

      # Update job as completed
      job.update!(
        status: "completed",
        processing_completed_at: Time.current,
        result: {
          routes_created: saved_routes.count,
          total_appointments: @appointments.count,
          time_saved_hours: savings[:time_saved_hours],
          cost_savings: savings[:cost_savings],
          efficiency_improvement: savings[:efficiency_improvement],
          optimization_metrics: {
            total_distance_km: saved_routes.sum(&:total_distance_meters) / 1000.0,
            average_route_duration: saved_routes.sum(&:total_duration_seconds) / saved_routes.count.to_f,
            appointments_per_route: (@appointments.count / saved_routes.count.to_f).round(2)
          }
        }
      )

      success_result(saved_routes, job)

    rescue StandardError => e
      Rails.logger.error "Route optimization failed: #{e.message}"
      job&.update!(status: "failed", result: { error: e.message })
      failed_result(e.message)
    end
  end

  private

  def load_appointments
    scope = @account.appointments
                   .where(scheduled_at: @date.beginning_of_day..@date.end_of_day)
                   .where(status: [ "scheduled", "confirmed" ])
                   .includes(:customer, :service_type, :staff)

    scope = scope.where(staff_id: @staff_ids) if @staff_ids.present?
    scope.to_a
  end

  def load_staff_members
    staff_ids = @appointments.map(&:staff_id).compact.uniq
    staff_ids &= @staff_ids if @staff_ids.present?
    @account.staff.where(id: staff_ids).to_a
  end

  def build_location_data
    locations = []

    # Add appointment locations
    @appointments.each do |appointment|
      locations << {
        id: appointment.id,
        type: "appointment",
        lat: appointment.customer.latitude,
        lng: appointment.customer.longitude,
        staff_id: appointment.staff_id,
        duration_minutes: appointment.service_type.duration_minutes,
        appointment: appointment
      }
    end

    # Add staff home locations
    @staff_members.each do |staff|
      locations << {
        id: "staff_home_#{staff.id}",
        type: "staff_home",
        lat: staff.home_latitude,
        lng: staff.home_longitude,
        staff_id: staff.id,
        duration_minutes: 0,
        staff: staff
      }
    end

    locations
  end

  def create_optimized_routes(distance_matrix)
    routes = []

    @staff_members.each do |staff|
      staff_appointments = @appointments.select { |apt| apt.staff_id == staff.id }
      next if staff_appointments.empty?

      route = optimize_single_staff_route(staff, staff_appointments, distance_matrix)
      routes << route if route
    end

    routes
  end

  def optimize_single_staff_route(staff, appointments, distance_matrix)
    return nil if appointments.empty?

    # Start from staff home
    current_location_id = "staff_home_#{staff.id}"
    route_appointments = []
    unvisited = appointments.dup
    total_distance = 0
    total_time = 0
    current_time = @date.beginning_of_day + 8.hours # Start at 8 AM

    # Nearest neighbor algorithm
    while unvisited.any?
      nearest_appointment = nil
      shortest_distance = Float::INFINITY

      unvisited.each do |appointment|
        key = "#{current_location_id}:#{appointment.id}"
        distance_data = distance_matrix[key]

        if distance_data && distance_data[:duration_seconds] < shortest_distance
          shortest_distance = distance_data[:duration_seconds]
          nearest_appointment = appointment
        end
      end

      if nearest_appointment
        # Add travel time
        key = "#{current_location_id}:#{nearest_appointment.id}"
        travel_data = distance_matrix[key]

        if travel_data
          total_distance += travel_data[:distance_meters]
          total_time += travel_data[:duration_seconds]
          current_time += travel_data[:duration_seconds].seconds
        end

        # Add service time
        service_duration = nearest_appointment.service_type.duration_minutes * 60
        total_time += service_duration

        route_appointments << {
          appointment: nearest_appointment,
          estimated_arrival: current_time,
          estimated_departure: current_time + service_duration.seconds,
          travel_distance: travel_data&.dig(:distance_meters) || 0,
          travel_time: travel_data&.dig(:duration_seconds) || 0
        }

        current_time += service_duration.seconds
        current_location_id = nearest_appointment.id
        unvisited.delete(nearest_appointment)
      else
        break # No reachable appointments
      end
    end

    # Return to staff home
    return_key = "#{current_location_id}:staff_home_#{staff.id}"
    return_data = distance_matrix[return_key]
    if return_data
      total_distance += return_data[:distance_meters]
      total_time += return_data[:duration_seconds]
    end

    {
      staff: staff,
      appointments: route_appointments,
      total_distance_meters: total_distance,
      total_duration_seconds: total_time,
      start_time: @date.beginning_of_day + 8.hours,
      end_time: current_time
    }
  end

  def save_routes_to_database(optimized_routes)
    saved_routes = []

    optimized_routes.each do |route_data|
      route = Route.create!(
        account: @account,
        scheduled_date: @date,
        status: "optimized",
        total_distance_meters: route_data[:total_distance_meters],
        total_duration_seconds: route_data[:total_duration_seconds]
      )

      route_data[:appointments].each_with_index do |stop_data, index|
        RouteStop.create!(
          route: route,
          appointment: stop_data[:appointment],
          stop_order: index,
          estimated_arrival: stop_data[:estimated_arrival],
          estimated_departure: stop_data[:estimated_departure]
        )

        # Update appointment with new timing
        stop_data[:appointment].update!(
          scheduled_at: stop_data[:estimated_arrival]
        )
      end

      saved_routes << route
    end

    saved_routes
  end

  def calculate_savings(routes, distance_matrix)
    # Estimate baseline (random order) vs optimized
    baseline_time = estimate_baseline_time
    optimized_time = routes.sum(&:total_duration_seconds)

    time_saved_hours = [ (baseline_time - optimized_time) / 3600.0, 0 ].max
    cost_per_hour = 25.0
    cost_savings = time_saved_hours * cost_per_hour
    efficiency_improvement = baseline_time > 0 ? (time_saved_hours / (baseline_time / 3600.0)) * 100 : 0

    {
      time_saved_hours: time_saved_hours.round(2),
      cost_savings: cost_savings.round(2),
      efficiency_improvement: efficiency_improvement.round(2)
    }
  end

  def estimate_baseline_time
    # Rough estimate: 30 minutes average between appointments + service time
    travel_time = @appointments.count * 30 * 60 # 30 min per appointment travel
    service_time = @appointments.sum { |apt| apt.service_type.duration_minutes * 60 }
    travel_time + service_time
  end

  def success_result(routes, job)
    {
      success: true,
      routes: routes,
      optimization_job: job,
      metrics: job.result
    }
  end

  def failed_result(error_message)
    {
      success: false,
      error: error_message,
      optimization_job: nil
    }
  end
end
</file>

<file path="db/migrate/20250831213446_create_flipper_tables.rb">
class CreateFlipperTables < ActiveRecord::Migration[8.0]
  def up
    create_table :flipper_features do |t|
      t.string :key, null: false
      t.timestamps null: false
    end
    add_index :flipper_features, :key, unique: true

    create_table :flipper_gates do |t|
      t.string :feature_key, null: false
      t.string :key, null: false
      t.text :value
      t.timestamps null: false
    end
    add_index :flipper_gates, [ :feature_key, :key, :value ], unique: true, length: { value: 255 }
  end

  def down
    drop_table :flipper_gates
    drop_table :flipper_features
  end
end
</file>

<file path="db/migrate/20250904185544_create_travel_segments.rb">
class CreateTravelSegments < ActiveRecord::Migration[8.0]
  def change
    create_table :travel_segments do |t|
      t.integer :from_appointment_id
      t.integer :to_appointment_id
      t.integer :distance_meters
      t.integer :duration_seconds
      t.decimal :traffic_factor, precision: 3, scale: 2

      t.timestamps
    end

    add_foreign_key :travel_segments, :appointments, column: :from_appointment_id
    add_foreign_key :travel_segments, :appointments, column: :to_appointment_id
    add_index :travel_segments, :from_appointment_id
    add_index :travel_segments, :to_appointment_id
  end
end
</file>

<file path="db/schema.rb">
# This file is auto-generated from the current state of the database. Instead
# of editing this file, please use the migrations feature of Active Record to
# incrementally modify your database, and then regenerate this schema definition.
#
# This file is the source Rails uses to define your schema when running `bin/rails
# db:schema:load`. When creating a new database, `bin/rails db:schema:load` tends to
# be faster and is potentially less error prone than running all of your
# migrations from scratch. Old migrations may fail to apply correctly if those
# migrations use external dependencies or application code.
#
# It's strongly recommended that you check this file into your version control system.

ActiveRecord::Schema[8.0].define(version: 2025_09_04_185646) do
  # These are extensions that must be enabled in order to support this database
  enable_extension "pg_catalog.plpgsql"

  create_table "accounts", force: :cascade do |t|
    t.string "name"
    t.bigint "vertical_id", null: false
    t.string "email"
    t.string "phone"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["vertical_id"], name: "index_accounts_on_vertical_id"
  end

  create_table "appointments", force: :cascade do |t|
    t.bigint "account_id", null: false
    t.bigint "customer_id", null: false
    t.bigint "service_type_id", null: false
    t.bigint "staff_id", null: false
    t.datetime "scheduled_at"
    t.integer "duration_minutes"
    t.string "status"
    t.text "notes"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["account_id"], name: "index_appointments_on_account_id"
    t.index ["customer_id"], name: "index_appointments_on_customer_id"
    t.index ["service_type_id"], name: "index_appointments_on_service_type_id"
    t.index ["staff_id"], name: "index_appointments_on_staff_id"
  end

  create_table "customers", force: :cascade do |t|
    t.bigint "account_id", null: false
    t.string "first_name"
    t.string "last_name"
    t.string "email"
    t.string "phone"
    t.text "address"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.decimal "latitude"
    t.decimal "longitude"
    t.string "geocoded_address"
    t.index ["account_id"], name: "index_customers_on_account_id"
  end

  create_table "flipper_features", force: :cascade do |t|
    t.string "key", null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["key"], name: "index_flipper_features_on_key", unique: true
  end

  create_table "flipper_gates", force: :cascade do |t|
    t.string "feature_key", null: false
    t.string "key", null: false
    t.text "value"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["feature_key", "key", "value"], name: "index_flipper_gates_on_feature_key_and_key_and_value", unique: true
  end

  create_table "optimization_jobs", force: :cascade do |t|
    t.bigint "account_id", null: false
    t.date "requested_date"
    t.string "status"
    t.json "parameters"
    t.json "result"
    t.datetime "processing_started_at"
    t.datetime "processing_completed_at"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["account_id"], name: "index_optimization_jobs_on_account_id"
  end

  create_table "route_stops", force: :cascade do |t|
    t.bigint "route_id", null: false
    t.bigint "appointment_id", null: false
    t.integer "stop_order"
    t.datetime "estimated_arrival"
    t.datetime "estimated_departure"
    t.datetime "actual_arrival"
    t.datetime "actual_departure"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["appointment_id"], name: "index_route_stops_on_appointment_id"
    t.index ["route_id"], name: "index_route_stops_on_route_id"
  end

  create_table "routes", force: :cascade do |t|
    t.bigint "account_id", null: false
    t.date "scheduled_date"
    t.string "status"
    t.integer "total_distance_meters"
    t.integer "total_duration_seconds"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["account_id"], name: "index_routes_on_account_id"
  end

  create_table "service_types", force: :cascade do |t|
    t.string "name"
    t.bigint "vertical_id", null: false
    t.integer "duration_minutes"
    t.boolean "requires_background_check"
    t.decimal "min_staff_ratio"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["vertical_id"], name: "index_service_types_on_vertical_id"
  end

  create_table "staffs", force: :cascade do |t|
    t.bigint "account_id", null: false
    t.string "first_name"
    t.string "last_name"
    t.string "email"
    t.string "phone"
    t.boolean "background_check_passed"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.decimal "home_latitude"
    t.decimal "home_longitude"
    t.integer "max_travel_radius_km"
    t.index ["account_id"], name: "index_staffs_on_account_id"
  end

  create_table "travel_segments", force: :cascade do |t|
    t.integer "from_appointment_id"
    t.integer "to_appointment_id"
    t.integer "distance_meters"
    t.integer "duration_seconds"
    t.decimal "traffic_factor", precision: 3, scale: 2
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["from_appointment_id"], name: "index_travel_segments_on_from_appointment_id"
    t.index ["to_appointment_id"], name: "index_travel_segments_on_to_appointment_id"
  end

  create_table "verticals", force: :cascade do |t|
    t.string "name"
    t.string "slug"
    t.text "description"
    t.boolean "active"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  add_foreign_key "accounts", "verticals"
  add_foreign_key "appointments", "accounts"
  add_foreign_key "appointments", "customers"
  add_foreign_key "appointments", "service_types"
  add_foreign_key "appointments", "staffs"
  add_foreign_key "customers", "accounts"
  add_foreign_key "optimization_jobs", "accounts"
  add_foreign_key "route_stops", "appointments"
  add_foreign_key "route_stops", "routes"
  add_foreign_key "routes", "accounts"
  add_foreign_key "service_types", "verticals"
  add_foreign_key "staffs", "accounts"
  add_foreign_key "travel_segments", "appointments", column: "from_appointment_id"
  add_foreign_key "travel_segments", "appointments", column: "to_appointment_id"
end
</file>

<file path="app/graphql/mutations/base_mutation.rb">
# frozen_string_literal: true

module Mutations
  class BaseMutation < GraphQL::Schema::Mutation
    argument_class Types::BaseArgument
    field_class Types::BaseField
    object_class Types::BaseObject
  end
end
</file>

<file path="app/graphql/types/account_type.rb">
# frozen_string_literal: true

module Types
  class AccountType < Types::BaseObject
    field :id, ID, null: false
    field :name, String, null: false
    field :email, String, null: false
    field :phone, String, null: false
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :vertical, Types::VerticalType, null: false
    field :customers, [ Types::CustomerType ], null: false
    field :staff, [ Types::StaffType ], null: false

    # Computed fields
    field :display_name_with_vertical, String, null: false
    field :total_customers, Integer, null: false
    field :total_staff, Integer, null: false

    # Business logic fields
    field :cleaning, Boolean, null: false
    field :elderly_care, Boolean, null: false
    field :requires_background_checks, Boolean, null: false

    def cleaning
      object.cleaning?
    end

    def elderly_care
      object.elderly_care?
    end

    def requires_background_checks
      object.requires_background_checks?
    end
  end
end
</file>

<file path="app/graphql/types/appointment_type.rb">
# frozen_string_literal: true

module Types
  class AppointmentType < Types::BaseObject
    field :id, ID, null: false
    field :scheduled_at, GraphQL::Types::ISO8601DateTime, null: false
    field :duration_minutes, Integer, null: false
    field :status, String, null: false
    field :notes, String, null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :account, Types::AccountType, null: false
    field :customer, Types::CustomerType, null: true
    field :service_type, Types::ServiceType, null: false
    field :staff, Types::StaffType, null: true

    # Computed fields
    field :duration_in_hours, String, null: false
    field :end_time, GraphQL::Types::ISO8601DateTime, null: false
    field :is_today, Boolean, null: false
    field :estimated_cost, Float, null: false do
      argument :hourly_rate, Float, required: false, default_value: 50.0
    end

    # Business logic fields
    field :vertical_name, String, null: false
    field :requires_compliance, Boolean, null: false

    def duration_in_hours
      hours = object.duration_minutes / 60.0
      if hours == hours.to_i
        "#{hours.to_i}h"
      else
        "#{hours}h"
      end
    end

    def end_time
      object.scheduled_at + object.duration_minutes.minutes
    end

    def is_today
      object.scheduled_at.to_date == Date.current
    end

    def estimated_cost(hourly_rate:)
      (object.duration_minutes / 60.0 * hourly_rate).round(2)
    end

    def vertical_name
      object.account.vertical.display_name
    end

    def requires_compliance
      object.account.vertical.requires_compliance_tracking?
    end
  end
end
</file>

<file path="app/graphql/types/customer_type.rb">
# frozen_string_literal: true

module Types
  class CustomerType < Types::BaseObject
    field :id, ID, null: false
    field :first_name, String, null: false
    field :last_name, String, null: false
    field :email, String, null: false
    field :phone, String, null: false
    field :address, String, null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :account, Types::AccountType, null: false

    # Computed fields
    field :full_name, String, null: false

    def full_name
      "#{object.first_name} #{object.last_name}"
    end
  end
end
</file>

<file path="app/graphql/types/staff_type.rb">
# frozen_string_literal: true

module Types
  class StaffType < Types::BaseObject
    field :id, ID, null: false
    field :first_name, String, null: false
    field :last_name, String, null: false
    field :email, String, null: false
    field :phone, String, null: false
    field :background_check_passed, Boolean, null: false
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :account, Types::AccountType, null: false

    # Computed fields
    field :full_name, String, null: false
    field :can_handle_sensitive_services, Boolean, null: false

    def full_name
      "#{object.first_name} #{object.last_name}"
    end

    def can_handle_sensitive_services
      object.background_check_passed
    end
  end
end
</file>

<file path="app/models/customer.rb">
class Customer < ApplicationRecord
  belongs_to :account

  def full_name
    "#{first_name} #{last_name}"
  end
end
</file>

<file path="app/models/staff.rb">
class Staff < ApplicationRecord
  belongs_to :account

  def full_name
    "#{first_name} #{last_name}"
  end
end
</file>

<file path="app/models/vertical.rb">
class TravelSegment < ApplicationRecord
  validates :distance_meters, presence: true, numericality: { greater_than: 0 }
  validates :duration_seconds, presence: true, numericality: { greater_than: 0 }
  validates :traffic_factor, numericality: { greater_than: 0 }, allow_nil: true

  def distance_km
    distance_meters / 1000.0
  end

  def duration_minutes
    duration_seconds / 60.0
  end
end
</file>

<file path="app/services/genetic_vrp_solver.rb">
# frozen_string_literal: true

class GeneticVRPSolver
  attr_reader :distance_matrix, :appointments, :staff_members, :objective, :max_iterations, :population_size

  def initialize(distance_matrix:, appointments:, staff_members:, objective: :minimize_time, max_iterations: 1000, population_size: 50)
    @distance_matrix = distance_matrix
    @appointments = appointments
    @staff_members = staff_members
    @objective = objective
    @max_iterations = max_iterations
    @population_size = population_size
    @mutation_rate = 0.15
    @crossover_rate = 0.8
    @elite_size = (population_size * 0.2).to_i
  end

  def solve
    return [] if appointments.empty? || staff_members.empty?

    # Generate initial population
    population = generate_initial_population

    best_solution = nil
    best_fitness = Float::INFINITY
    stagnation_counter = 0
    max_stagnation = 100

    max_iterations.times do |generation|
      # Evaluate fitness for all solutions
      fitness_scores = population.map { |solution| calculate_fitness(solution) }

      # Track best solution
      current_best_index = fitness_scores.each_with_index.min_by { |fitness, _| fitness }[1]
      current_best_fitness = fitness_scores[current_best_index]

      if current_best_fitness < best_fitness
        best_fitness = current_best_fitness
        best_solution = population[current_best_index].deep_dup
        stagnation_counter = 0
      else
        stagnation_counter += 1
      end

      # Early termination if no improvement
      break if stagnation_counter >= max_stagnation

      # Create next generation
      population = evolve_population(population, fitness_scores)

      # Log progress periodically
      if generation % 100 == 0
        Rails.logger.info "Generation #{generation}: Best fitness = #{best_fitness.round(2)}"
      end
    end

    convert_solution_to_routes(best_solution)
  end

  private

  def generate_initial_population
    population = []

    # Generate diverse initial solutions
    population_size.times do
      solution = create_random_solution
      population << solution
    end

    # Add some greedy solutions for better starting point
    (population_size * 0.2).to_i.times do
      solution = create_greedy_solution
      population << solution
      population.pop # Remove a random solution
    end

    population
  end

  def create_random_solution
    # Randomly assign appointments to staff members
    solution = staff_members.map.with_index do |staff, staff_index|
      {
        staff_id: staff.id,
        staff_index: staff_index,
        appointments: [],
        home_location: staff_home_location(staff)
      }
    end

    # Randomly distribute appointments
    appointments.each do |appointment|
      available_staff = solution.select { |route| can_assign_appointment?(route[:staff_id], appointment) }
      next if available_staff.empty?

      random_staff = available_staff.sample
      random_staff[:appointments] << appointment.id
    end

    # Shuffle appointment order within each route
    solution.each { |route| route[:appointments].shuffle! }
    solution
  end

  def create_greedy_solution
    # Nearest neighbor heuristic
    solution = staff_members.map.with_index do |staff, staff_index|
      {
        staff_id: staff.id,
        staff_index: staff_index,
        appointments: [],
        home_location: staff_home_location(staff)
      }
    end

    unassigned = appointments.map(&:id)

    while unassigned.any?
      best_insertion = nil
      best_cost = Float::INFINITY

      solution.each do |route|
        next if route[:appointments].count >= max_appointments_per_route

        unassigned.each do |appointment_id|
          appointment = appointments.find { |a| a.id == appointment_id }
          next unless can_assign_appointment?(route[:staff_id], appointment)

          # Try inserting at each position
          (0..route[:appointments].length).each do |position|
            cost = insertion_cost(route, appointment_id, position)
            if cost < best_cost
              best_cost = cost
              best_insertion = { route: route, appointment_id: appointment_id, position: position }
            end
          end
        end
      end

      if best_insertion
        best_insertion[:route][:appointments].insert(best_insertion[:position], best_insertion[:appointment_id])
        unassigned.delete(best_insertion[:appointment_id])
      else
        break # No valid insertions found
      end
    end

    solution
  end

  def evolve_population(population, fitness_scores)
    new_population = []

    # Elitism: Keep best solutions
    elite_indices = fitness_scores.each_with_index.sort_by { |fitness, _| fitness }.first(elite_size).map { |_, index| index }
    elite_indices.each { |index| new_population << population[index].deep_dup }

    # Generate offspring through crossover and mutation
    while new_population.size < population_size
      # Tournament selection
      parent1 = tournament_selection(population, fitness_scores)
      parent2 = tournament_selection(population, fitness_scores)

      # Crossover
      if rand < crossover_rate
        offspring1, offspring2 = crossover(parent1, parent2)
      else
        offspring1, offspring2 = parent1.deep_dup, parent2.deep_dup
      end

      # Mutation
      mutate!(offspring1) if rand < mutation_rate
      mutate!(offspring2) if rand < mutation_rate

      new_population << offspring1
      new_population << offspring2 if new_population.size < population_size
    end

    new_population.first(population_size)
  end

  def tournament_selection(population, fitness_scores, tournament_size = 3)
    tournament_indices = (0...population.size).to_a.sample(tournament_size)
    best_index = tournament_indices.min_by { |index| fitness_scores[index] }
    population[best_index]
  end

  def crossover(parent1, parent2)
    offspring1 = deep_copy_solution(parent1)
    offspring2 = deep_copy_solution(parent2)

    # Order crossover for route sequences
    staff_members.each_with_index do |staff, staff_index|
      route1 = parent1[staff_index][:appointments]
      route2 = parent2[staff_index][:appointments]

      if route1.any? && route2.any?
        # Swap segments between routes
        point1 = rand(route1.length)
        point2 = rand(route1.length)
        point1, point2 = point2, point1 if point1 > point2

        segment1 = route1[point1..point2]
        segment2 = route2[point1..point2]

        # Remove conflicting appointments and insert segments
        offspring1[staff_index][:appointments] = (route1 - segment2) + segment2
        offspring2[staff_index][:appointments] = (route2 - segment1) + segment1
      end
    end

    [ offspring1, offspring2 ]
  end

  def mutate!(solution)
    mutation_type = rand(4)

    case mutation_type
    when 0 # Swap appointments within a route
      route = solution.select { |r| r[:appointments].count > 1 }.sample
      return unless route

      i, j = route[:appointments].sample(2)
      route[:appointments][i], route[:appointments][j] = route[:appointments][j], route[:appointments][i]

    when 1 # Move appointment between routes
      from_route = solution.select { |r| r[:appointments].any? }.sample
      to_route = solution.sample
      return unless from_route && to_route && from_route != to_route

      appointment_id = from_route[:appointments].delete_at(rand(from_route[:appointments].length))
      appointment = appointments.find { |a| a.id == appointment_id }

      if can_assign_appointment?(to_route[:staff_id], appointment)
        to_route[:appointments] << appointment_id
      else
        from_route[:appointments] << appointment_id # Revert if invalid
      end

    when 2 # Reverse segment within route
      route = solution.select { |r| r[:appointments].count > 2 }.sample
      return unless route

      start_idx = rand(route[:appointments].length - 1)
      end_idx = start_idx + rand(route[:appointments].length - start_idx)
      route[:appointments][start_idx..end_idx] = route[:appointments][start_idx..end_idx].reverse

    when 3 # 2-opt improvement within route
      route = solution.select { |r| r[:appointments].count > 3 }.sample
      return unless route

      perform_2opt!(route[:appointments])
    end
  end

  def perform_2opt!(route_appointments)
    return if route_appointments.length < 4

    best_distance = calculate_route_distance(route_appointments)
    improved = true

    while improved
      improved = false

      (0...route_appointments.length - 1).each do |i|
        (i + 1...route_appointments.length).each do |j|
          # Swap edges
          new_route = route_appointments.dup
          new_route[i + 1..j] = new_route[i + 1..j].reverse

          new_distance = calculate_route_distance(new_route)
          if new_distance < best_distance
            route_appointments.replace(new_route)
            best_distance = new_distance
            improved = true
            break
          end
        end
        break if improved
      end
    end
  end

  def calculate_fitness(solution)
    total_cost = 0.0

    solution.each do |route|
      next if route[:appointments].empty?

      route_cost = case objective
      when :minimize_time
                     calculate_total_travel_time(route)
      when :minimize_distance
                     calculate_total_distance(route)
      when :balance_workload
                     calculate_workload_balance_penalty(solution)
      else
                     calculate_total_travel_time(route)
      end

      # Add constraint violations as penalties
      route_cost += constraint_penalty(route)
      total_cost += route_cost
    end

    total_cost
  end

  def calculate_total_travel_time(route)
    return 0.0 if route[:appointments].empty?

    total_time = 0.0
    current_location = route[:home_location]

    route[:appointments].each do |appointment_id|
      appointment = appointments.find { |a| a.id == appointment_id }
      appointment_location = appointment_location(appointment)

      # Travel time to appointment
      travel_time = get_travel_time(current_location, appointment_location)
      total_time += travel_time

      # Service time
      total_time += appointment.service_type.duration_minutes * 60

      current_location = appointment_location
    end

    # Return home
    total_time += get_travel_time(current_location, route[:home_location])
    total_time
  end

  def calculate_total_distance(route)
    return 0.0 if route[:appointments].empty?

    total_distance = 0.0
    current_location = route[:home_location]

    route[:appointments].each do |appointment_id|
      appointment = appointments.find { |a| a.id == appointment_id }
      appointment_location = appointment_location(appointment)

      # Travel distance to appointment
      travel_distance = get_travel_distance(current_location, appointment_location)
      total_distance += travel_distance

      current_location = appointment_location
    end

    # Return home
    total_distance += get_travel_distance(current_location, route[:home_location])
    total_distance
  end

  def get_travel_time(from_location, to_location)
    key = "#{from_location[:id]}:#{to_location[:id]}"
    distance_data = distance_matrix[key]
    return 1800 unless distance_data # Default 30 min if no data

    distance_data[:duration_seconds] || 1800
  end

  def get_travel_distance(from_location, to_location)
    key = "#{from_location[:id]}:#{to_location[:id]}"
    distance_data = distance_matrix[key]
    return 10000 unless distance_data # Default 10km if no data

    distance_data[:distance_meters] || 10000
  end

  def constraint_penalty(route)
    penalty = 0.0

    # Max appointments per staff per day
    if route[:appointments].count > max_appointments_per_route
      penalty += (route[:appointments].count - max_appointments_per_route) * 3600
    end

    # Max working hours constraint
    total_work_time = calculate_total_travel_time(route)
    max_work_seconds = 8 * 3600 # 8 hours
    if total_work_time > max_work_seconds
      penalty += (total_work_time - max_work_seconds) * 2 # Double penalty for overtime
    end

    penalty
  end

  def calculate_workload_balance_penalty(solution)
    work_times = solution.map { |route| calculate_total_travel_time(route) }
    return 0.0 if work_times.empty?

    avg_time = work_times.sum / work_times.length.to_f
    variance = work_times.sum { |time| (time - avg_time) ** 2 } / work_times.length.to_f

    Math.sqrt(variance) # Standard deviation as penalty
  end

  def calculate_route_distance(appointment_ids)
    return 0.0 if appointment_ids.empty?

    total_distance = 0.0

    appointment_ids.each_cons(2) do |from_id, to_id|
      from_appointment = appointments.find { |a| a.id == from_id }
      to_appointment = appointments.find { |a| a.id == to_id }

      from_location = appointment_location(from_appointment)
      to_location = appointment_location(to_appointment)

      total_distance += get_travel_distance(from_location, to_location)
    end

    total_distance
  end

  def convert_solution_to_routes(solution)
    return [] unless solution

    routes = []

    solution.each do |route_data|
      next if route_data[:appointments].empty?

      staff = staff_members.find { |s| s.id == route_data[:staff_id] }
      route_appointments = route_data[:appointments].map do |appointment_id|
        appointments.find { |a| a.id == appointment_id }
      end

      total_distance = calculate_total_distance(route_data)
      total_time = calculate_total_travel_time(route_data)

      routes << {
        staff: staff,
        appointments: route_appointments,
        total_distance_meters: total_distance,
        total_duration_seconds: total_time,
        stops: build_route_stops(route_appointments)
      }
    end

    routes
  end

  def build_route_stops(route_appointments)
    stops = []
    current_time = Time.current.beginning_of_day + 8.hours

    route_appointments.each_with_index do |appointment, index|
      service_duration = appointment.service_type.duration_minutes.minutes

      stops << {
        appointment_id: appointment.id,
        estimated_arrival: current_time,
        estimated_departure: current_time + service_duration,
        stop_order: index
      }

      current_time += service_duration

      # Add travel time to next appointment if not last
      if index < route_appointments.length - 1
        next_appointment = route_appointments[index + 1]
        travel_time = get_travel_time(
          appointment_location(appointment),
          appointment_location(next_appointment)
        )
        current_time += travel_time.seconds
      end
    end

    stops
  end

  # Helper methods
  def staff_home_location(staff)
    {
      id: "staff_home_#{staff.id}",
      lat: staff.home_latitude || 53.5461, # Default Edmonton coordinates
      lng: staff.home_longitude || -113.4938
    }
  end

  def appointment_location(appointment)
    {
      id: appointment.id,
      lat: appointment.customer.latitude,
      lng: appointment.customer.longitude
    }
  end

  def can_assign_appointment?(staff_id, appointment)
    # Basic assignment rules - can be expanded
    appointment.staff_id == staff_id
  end

  def max_appointments_per_route
    8 # Maximum appointments per staff per day
  end

  def insertion_cost(route, appointment_id, position)
    # Calculate cost of inserting appointment at given position
    return 0.0 if route[:appointments].empty?

    appointment = appointments.find { |a| a.id == appointment_id }
    appointment_loc = appointment_location(appointment)

    if position == 0
      # Insert at beginning
      home_loc = route[:home_location]
      next_appointment = appointments.find { |a| a.id == route[:appointments][0] }
      next_loc = appointment_location(next_appointment)

      # Cost = home -> new + new -> next - home -> next
      new_cost = get_travel_time(home_loc, appointment_loc) +
                 get_travel_time(appointment_loc, next_loc)
      old_cost = get_travel_time(home_loc, next_loc)

      new_cost - old_cost
    elsif position == route[:appointments].length
      # Insert at end
      prev_appointment = appointments.find { |a| a.id == route[:appointments][-1] }
      prev_loc = appointment_location(prev_appointment)
      home_loc = route[:home_location]

      # Cost = prev -> new + new -> home - prev -> home
      new_cost = get_travel_time(prev_loc, appointment_loc) +
                 get_travel_time(appointment_loc, home_loc)
      old_cost = get_travel_time(prev_loc, home_loc)

      new_cost - old_cost
    else
      # Insert in middle
      prev_appointment = appointments.find { |a| a.id == route[:appointments][position - 1] }
      next_appointment = appointments.find { |a| a.id == route[:appointments][position] }

      prev_loc = appointment_location(prev_appointment)
      next_loc = appointment_location(next_appointment)

      # Cost = prev -> new + new -> next - prev -> next
      new_cost = get_travel_time(prev_loc, appointment_loc) +
                 get_travel_time(appointment_loc, next_loc)
      old_cost = get_travel_time(prev_loc, next_loc)

      new_cost - old_cost
    end
  end

  def deep_copy_solution(solution)
    solution.map do |route|
      {
        staff_id: route[:staff_id],
        staff_index: route[:staff_index],
        appointments: route[:appointments].dup,
        home_location: route[:home_location].dup
      }
    end
  end
end
</file>

<file path="config/application.rb">
require_relative "boot"

require "rails"
# Pick the frameworks you want:
require "active_model/railtie"
require "active_job/railtie"
require "active_record/railtie"
require "active_storage/engine"
require "action_controller/railtie"
require "action_mailer/railtie"
require "action_mailbox/engine"
require "action_text/engine"
require "action_view/railtie"
require "action_cable/engine"
# require "rails/test_unit/railtie"

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(*Rails.groups)

module Carestack
  class Application < Rails::Application
    config.active_record.query_log_tags_enabled = true
    config.active_record.query_log_tags = [
      # Rails query log tags:
      :application, :controller, :action, :job,
      # GraphQL-Ruby query log tags:
      current_graphql_operation: -> { GraphQL::Current.operation_name },
      current_graphql_field: -> { GraphQL::Current.field&.path },
      current_dataloader_source: -> { GraphQL::Current.dataloader_source_class }
    ]
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 8.0

    # Please, add to the `ignore` list any other `lib` subdirectories that do
    # not contain `.rb` files, or that should not be reloaded or eager loaded.
    # Common ones are `templates`, `generators`, or `middleware`, for example.
    config.autoload_lib(ignore: %w[assets tasks])

    # Configuration for the application, engines, and railties goes here.
    #
    # These settings can be overridden in specific environments using the files
    # in config/environments, which are processed later.
    #
    # config.time_zone = "Central Time (US & Canada)"
    # config.eager_load_paths << Rails.root.join("extras")

    # Only loads a smaller set of middleware suitable for API only apps.
    # Middleware like session, flash, cookies can be added back manually.
    # Skip views, helpers and assets when generating a new resource.
    config.api_only = true
  end
end
</file>

<file path="config/routes.rb">
Rails.application.routes.draw do
  post "/graphql", to: "graphql#execute"

  if Rails.env.development?
    mount GraphiQL::Rails::Engine, at: "/graphiql", graphql_path: "/graphql"
  end

  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html

  # Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500.
  # Can be used by load balancers and uptime monitors to verify that the app is live.
  get "up" => "rails/health#show", as: :rails_health_check
end
</file>

<file path="app/graphql/types/mutation_type.rb">
# frozen_string_literal: true

module Types
  class MutationType < Types::BaseObject
    field :create_appointment, mutation: Mutations::CreateAppointment
    field :optimize_routes, mutation: Mutations::OptimizeRoutes
  end
end
</file>

<file path="Gemfile">
source "https://rubygems.org"

ruby "3.2.0"

# Rails Core
gem "rails", "~> 8.0.0"
gem "bootsnap", require: false
gem "dotenv-rails", groups: %i[development test]

# Database & Persistence
gem "pg", "~> 1.1"
gem "ulid", "~> 1.2.0"
gem "discard", "~> 1.2"
gem "will_paginate", "~> 4.0"

# API & GraphQL
gem "graphql", "~> 2.0"
gem "jbuilder"

# Background Jobs
gem "sidekiq", "~> 7.0"
gem "redis", "> 5"

# Authentication & Authorization
gem "devise", "~> 4.9"
gem "jwt", "~> 2.7"

# Forms & Validation
gem "reform-rails"
gem "reform"

# File Uploads
gem "shrine", "~> 3.0"
gem "image_processing", "~> 1.8"

# Feature Flags
gem "flipper"
gem "flipper-active_record"
gem "flipper-ui"

# Payments (like ZenMaid)
gem "stripe", "~> 5.55"
gem "stripe_event", "~> 2.3"

# Utils & Helpers
gem "money-rails"
gem "chronic", "~> 0.10"
gem "sanitize"
gem "oj"

# Scheduling & Calendar
gem "icalendar", "~> 2.4"
gem "ice_cube"

# Decorators
gem "draper"

# Error Tracking
gem "rollbar"

group :development, :test do
  gem "pry-rails"
  gem "pry-byebug"
  gem "rspec-rails"
  gem "factory_bot_rails"
  gem "faker"
  gem "timecop"
  gem "brakeman", require: false
  gem "rubocop", require: false
  gem "rubocop-rails", require: false
  gem "rubocop-rails-omakase", require: false
end

group :development do
  gem "listen"
  gem "bullet"
  gem "graphiql-rails"
  gem "letter_opener"
  gem "annotate"
  gem "graphiql-rails"
end

group :test do
  gem "capybara"
  gem "database_cleaner-active_record"
  gem "rspec-sidekiq"
  gem "webmock"
  gem "simplecov", require: false
end

group :production do
  gem "puma", "~> 6.0"
  gem "rack-cors"
end
</file>

</files>
