This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
  dependabot.yml
.kamal/
  hooks/
    docker-setup.sample
    post-app-boot.sample
    post-deploy.sample
    post-proxy-reboot.sample
    pre-app-boot.sample
    pre-build.sample
    pre-connect.sample
    pre-deploy.sample
    pre-proxy-reboot.sample
  secrets
app/
  controllers/
    application_controller.rb
    graphql_controller.rb
  graphql/
    mutations/
      base_mutation.rb
      create_appointment.rb
    resolvers/
      base_resolver.rb
    types/
      account_type.rb
      appointment_type.rb
      base_argument.rb
      base_connection.rb
      base_edge.rb
      base_enum.rb
      base_field.rb
      base_input_object.rb
      base_interface.rb
      base_object.rb
      base_scalar.rb
      base_union.rb
      create_appointment_input.rb
      customer_type.rb
      mutation_type.rb
      node_type.rb
      query_type.rb
      service_type.rb
      staff_type.rb
      vertical_type.rb
    carestack_schema.rb
  jobs/
    application_job.rb
  mailers/
    application_mailer.rb
  models/
    account.rb
    application_record.rb
    appointment.rb
    customer.rb
    service_type.rb
    staff.rb
    vertical.rb
  views/
    layouts/
      mailer.html.erb
      mailer.text.erb
bin/
  brakeman
  bundle
  dev
  docker-entrypoint
  jobs
  kamal
  rails
  rake
  rubocop
  setup
  thrust
config/
  environments/
    development.rb
    production.rb
    test.rb
  initializers/
    cors.rb
    filter_parameter_logging.rb
    inflections.rb
  locales/
    en.yml
  application.rb
  boot.rb
  cable.yml
  cache.yml
  credentials.yml.enc
  database.yml
  deploy.yml
  environment.rb
  puma.rb
  queue.yml
  recurring.yml
  routes.rb
  storage.yml
db/
  migrate/
    20250831202143_create_verticals.rb
    20250831202159_create_accounts.rb
    20250831202216_create_service_types.rb
    20250831202229_create_customers.rb
    20250831202241_create_staffs.rb
    20250831202253_create_appointments.rb
    20250831213446_create_flipper_tables.rb
  cable_schema.rb
  cache_schema.rb
  queue_schema.rb
  schema.rb
  seeds.rb
public/
  robots.txt
spec/
  factories/
    accounts.rb
    appointments.rb
    customers.rb
    service_types.rb
    staffs.rb
    verticals.rb
  models/
    account_spec.rb
    appointment_spec.rb
    customer_spec.rb
    service_type_spec.rb
    staff_spec.rb
    vertical_spec.rb
.dockerignore
.gitattributes
.gitignore
.rubocop.yml
.ruby-version
config.ru
Dockerfile
Gemfile
Rakefile
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/graphql/mutations/create_appointment.rb">
# frozen_string_literal: true

module Mutations
  class CreateAppointment < BaseMutation
    description "Create a new appointment with vertical-specific business rules"

    # Direct arguments (simpler approach)
    argument :account_id, ID, required: true
    argument :customer_id, ID, required: true
    argument :service_type_id, ID, required: true
    argument :staff_id, ID, required: true
    argument :scheduled_at, GraphQL::Types::ISO8601DateTime, required: true
    argument :notes, String, required: false

    # Return type
    field :appointment, Types::AppointmentType, null: true
    field :errors, [String], null: false

    def resolve(account_id:, customer_id:, service_type_id:, staff_id:, scheduled_at:, notes: nil)
      appointment = nil
      errors = []

      begin
        # Load all required records
        account = Account.find(account_id)
        customer = Customer.find(customer_id)
        service_type = ServiceType.find(service_type_id)
        staff = Staff.find(staff_id)

        # Validate business rules based on vertical
        validation_errors = validate_appointment_rules(account, service_type, staff)
        
        if validation_errors.any?
          return {
            appointment: nil,
            errors: validation_errors
          }
        end

        # Create the appointment
        appointment = Appointment.create!(
          account: account,
          customer: customer,
          service_type: service_type,
          staff: staff,
          scheduled_at: scheduled_at,
          duration_minutes: service_type.duration_minutes,
          status: 'scheduled',
          notes: notes
        )

        {
          appointment: appointment,
          errors: []
        }

      rescue ActiveRecord::RecordNotFound => e
        {
          appointment: nil,
          errors: ["Record not found: #{e.message}"]
        }
      rescue ActiveRecord::RecordInvalid => e
        {
          appointment: nil,
          errors: e.record.errors.full_messages
        }
      rescue StandardError => e
        {
          appointment: nil,
          errors: ["An error occurred: #{e.message}"]
        }
      end
    end

    private

    def validate_appointment_rules(account, service_type, staff)
      errors = []

      # Verify service type belongs to account's vertical
      unless service_type.vertical == account.vertical
        errors << "Service type '#{service_type.name}' is not available for #{account.vertical.display_name} businesses"
      end

      # Verify staff belongs to the account
      unless staff.account == account
        errors << "Staff member does not belong to this account"
      end

      # Vertical-specific validations
      case account.vertical.slug
      when /cleaning/
        errors.concat(validate_cleaning_rules(account, service_type, staff))
      when /elderly_care/
        errors.concat(validate_elderly_care_rules(account, service_type, staff))
      end

      errors
    end

    def validate_cleaning_rules(account, service_type, staff)
      errors = []

      # For post-construction cleanup, require background check
      if service_type.requires_background_check && !staff.background_check_passed
        errors << "Staff member must have passed background check for '#{service_type.name}' service"
      end

      errors
    end

    def validate_elderly_care_rules(account, service_type, staff)
      errors = []

      # Elderly care always requires background checks
      unless staff.background_check_passed
        errors << "All elderly care staff must have passed background checks"
      end

      # Check minimum staff ratio requirements
      if service_type.min_staff_ratio.present? && service_type.min_staff_ratio > 1
        errors << "This service type requires #{service_type.min_staff_ratio} staff members minimum (multi-staff booking not yet implemented)"
      end

      errors
    end
  end
end
</file>

<file path="app/graphql/types/create_appointment_input.rb">
# frozen_string_literal: true

module Types
  class CreateAppointmentInput < Types::BaseInputObject
    argument :account_id, ID, required: true, as: :accountId
    argument :customer_id, ID, required: true, as: :customerId
    argument :service_type_id, ID, required: true, as: :serviceTypeId
    argument :staff_id, ID, required: true, as: :staffId
    argument :scheduled_at, GraphQL::Types::ISO8601DateTime, required: true, as: :scheduledAt
    argument :notes, String, required: false
  end
end
</file>

<file path=".github/workflows/ci.yml">
name: CI

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  scan_ruby:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: .ruby-version
          bundler-cache: true

      - name: Scan for common Rails security vulnerabilities using static analysis
        run: bin/brakeman --no-pager

  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: .ruby-version
          bundler-cache: true

      - name: Lint code for consistent style
        run: bin/rubocop -f github
</file>

<file path=".github/dependabot.yml">
version: 2
updates:
- package-ecosystem: bundler
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10
- package-ecosystem: github-actions
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10
</file>

<file path=".kamal/hooks/docker-setup.sample">
#!/bin/sh

echo "Docker set up on $KAMAL_HOSTS..."
</file>

<file path=".kamal/hooks/post-app-boot.sample">
#!/bin/sh

echo "Booted app version $KAMAL_VERSION on $KAMAL_HOSTS..."
</file>

<file path=".kamal/hooks/post-deploy.sample">
#!/bin/sh

# A sample post-deploy hook
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_ROLES (if set)
# KAMAL_DESTINATION (if set)
# KAMAL_RUNTIME

echo "$KAMAL_PERFORMER deployed $KAMAL_VERSION to $KAMAL_DESTINATION in $KAMAL_RUNTIME seconds"
</file>

<file path=".kamal/hooks/post-proxy-reboot.sample">
#!/bin/sh

echo "Rebooted kamal-proxy on $KAMAL_HOSTS"
</file>

<file path=".kamal/hooks/pre-app-boot.sample">
#!/bin/sh

echo "Booting app version $KAMAL_VERSION on $KAMAL_HOSTS..."
</file>

<file path=".kamal/hooks/pre-build.sample">
#!/bin/sh

# A sample pre-build hook
#
# Checks:
# 1. We have a clean checkout
# 2. A remote is configured
# 3. The branch has been pushed to the remote
# 4. The version we are deploying matches the remote
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_ROLES (if set)
# KAMAL_DESTINATION (if set)

if [ -n "$(git status --porcelain)" ]; then
  echo "Git checkout is not clean, aborting..." >&2
  git status --porcelain >&2
  exit 1
fi

first_remote=$(git remote)

if [ -z "$first_remote" ]; then
  echo "No git remote set, aborting..." >&2
  exit 1
fi

current_branch=$(git branch --show-current)

if [ -z "$current_branch" ]; then
  echo "Not on a git branch, aborting..." >&2
  exit 1
fi

remote_head=$(git ls-remote $first_remote --tags $current_branch | cut -f1)

if [ -z "$remote_head" ]; then
  echo "Branch not pushed to remote, aborting..." >&2
  exit 1
fi

if [ "$KAMAL_VERSION" != "$remote_head" ]; then
  echo "Version ($KAMAL_VERSION) does not match remote HEAD ($remote_head), aborting..." >&2
  exit 1
fi

exit 0
</file>

<file path=".kamal/hooks/pre-connect.sample">
#!/usr/bin/env ruby

# A sample pre-connect check
#
# Warms DNS before connecting to hosts in parallel
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_ROLES (if set)
# KAMAL_DESTINATION (if set)
# KAMAL_RUNTIME

hosts = ENV["KAMAL_HOSTS"].split(",")
results = nil
max = 3

elapsed = Benchmark.realtime do
  results = hosts.map do |host|
    Thread.new do
      tries = 1

      begin
        Socket.getaddrinfo(host, 0, Socket::AF_UNSPEC, Socket::SOCK_STREAM, nil, Socket::AI_CANONNAME)
      rescue SocketError
        if tries < max
          puts "Retrying DNS warmup: #{host}"
          tries += 1
          sleep rand
          retry
        else
          puts "DNS warmup failed: #{host}"
          host
        end
      end

      tries
    end
  end.map(&:value)
end

retries = results.sum - hosts.size
nopes = results.count { |r| r == max }

puts "Prewarmed %d DNS lookups in %.2f sec: %d retries, %d failures" % [ hosts.size, elapsed, retries, nopes ]
</file>

<file path=".kamal/hooks/pre-deploy.sample">
#!/usr/bin/env ruby

# A sample pre-deploy hook
#
# Checks the Github status of the build, waiting for a pending build to complete for up to 720 seconds.
#
# Fails unless the combined status is "success"
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_COMMAND
# KAMAL_SUBCOMMAND
# KAMAL_ROLES (if set)
# KAMAL_DESTINATION (if set)

# Only check the build status for production deployments
if ENV["KAMAL_COMMAND"] == "rollback" || ENV["KAMAL_DESTINATION"] != "production"
  exit 0
end

require "bundler/inline"

# true = install gems so this is fast on repeat invocations
gemfile(true, quiet: true) do
  source "https://rubygems.org"

  gem "octokit"
  gem "faraday-retry"
end

MAX_ATTEMPTS = 72
ATTEMPTS_GAP = 10

def exit_with_error(message)
  $stderr.puts message
  exit 1
end

class GithubStatusChecks
  attr_reader :remote_url, :git_sha, :github_client, :combined_status

  def initialize
    @remote_url = github_repo_from_remote_url
    @git_sha = `git rev-parse HEAD`.strip
    @github_client = Octokit::Client.new(access_token: ENV["GITHUB_TOKEN"])
    refresh!
  end

  def refresh!
    @combined_status = github_client.combined_status(remote_url, git_sha)
  end

  def state
    combined_status[:state]
  end

  def first_status_url
    first_status = combined_status[:statuses].find { |status| status[:state] == state }
    first_status && first_status[:target_url]
  end

  def complete_count
    combined_status[:statuses].count { |status| status[:state] != "pending"}
  end

  def total_count
    combined_status[:statuses].count
  end

  def current_status
    if total_count > 0
      "Completed #{complete_count}/#{total_count} checks, see #{first_status_url} ..."
    else
      "Build not started..."
    end
  end

  private
    def github_repo_from_remote_url
      url = `git config --get remote.origin.url`.strip.delete_suffix(".git")
      if url.start_with?("https://github.com/")
        url.delete_prefix("https://github.com/")
      elsif url.start_with?("git@github.com:")
        url.delete_prefix("git@github.com:")
      else
        url
      end
    end
end


$stdout.sync = true

begin
  puts "Checking build status..."

  attempts = 0
  checks = GithubStatusChecks.new

  loop do
    case checks.state
    when "success"
      puts "Checks passed, see #{checks.first_status_url}"
      exit 0
    when "failure"
      exit_with_error "Checks failed, see #{checks.first_status_url}"
    when "pending"
      attempts += 1
    end

    exit_with_error "Checks are still pending, gave up after #{MAX_ATTEMPTS * ATTEMPTS_GAP} seconds" if attempts == MAX_ATTEMPTS

    puts checks.current_status
    sleep(ATTEMPTS_GAP)
    checks.refresh!
  end
rescue Octokit::NotFound
  exit_with_error "Build status could not be found"
end
</file>

<file path=".kamal/hooks/pre-proxy-reboot.sample">
#!/bin/sh

echo "Rebooting kamal-proxy on $KAMAL_HOSTS..."
</file>

<file path=".kamal/secrets">
# Secrets defined here are available for reference under registry/password, env/secret, builder/secrets,
# and accessories/*/env/secret in config/deploy.yml. All secrets should be pulled from either
# password manager, ENV, or a file. DO NOT ENTER RAW CREDENTIALS HERE! This file needs to be safe for git.

# Example of extracting secrets from 1password (or another compatible pw manager)
# SECRETS=$(kamal secrets fetch --adapter 1password --account your-account --from Vault/Item KAMAL_REGISTRY_PASSWORD RAILS_MASTER_KEY)
# KAMAL_REGISTRY_PASSWORD=$(kamal secrets extract KAMAL_REGISTRY_PASSWORD ${SECRETS})
# RAILS_MASTER_KEY=$(kamal secrets extract RAILS_MASTER_KEY ${SECRETS})

# Use a GITHUB_TOKEN if private repositories are needed for the image
# GITHUB_TOKEN=$(gh config get -h github.com oauth_token)

# Grab the registry password from ENV
KAMAL_REGISTRY_PASSWORD=$KAMAL_REGISTRY_PASSWORD

# Improve security by using a password manager. Never check config/master.key into git!
RAILS_MASTER_KEY=$(cat config/master.key)
</file>

<file path="app/controllers/application_controller.rb">
class ApplicationController < ActionController::API
end
</file>

<file path="app/controllers/graphql_controller.rb">
# frozen_string_literal: true

class GraphqlController < ApplicationController
  # If accessing from outside this domain, nullify the session
  # This allows for outside API access while preventing CSRF attacks,
  # but you'll have to authenticate your user separately
  # protect_from_forgery with: :null_session

  def execute
    variables = prepare_variables(params[:variables])
    query = params[:query]
    operation_name = params[:operationName]
    context = {
      # Query context goes here, for example:
      # current_user: current_user,
    }
    result = CarestackSchema.execute(query, variables: variables, context: context, operation_name: operation_name)
    render json: result
  rescue StandardError => e
    raise e unless Rails.env.development?
    handle_error_in_development(e)
  end

  private

  # Handle variables in form data, JSON body, or a blank value
  def prepare_variables(variables_param)
    case variables_param
    when String
      if variables_param.present?
        JSON.parse(variables_param) || {}
      else
        {}
      end
    when Hash
      variables_param
    when ActionController::Parameters
      variables_param.to_unsafe_hash # GraphQL-Ruby will validate name and type of incoming variables.
    when nil
      {}
    else
      raise ArgumentError, "Unexpected parameter: #{variables_param}"
    end
  end

  def handle_error_in_development(e)
    logger.error e.message
    logger.error e.backtrace.join("\n")

    render json: { errors: [{ message: e.message, backtrace: e.backtrace }], data: {} }, status: 500
  end
end
</file>

<file path="app/graphql/mutations/base_mutation.rb">
# frozen_string_literal: true

module Mutations
  class BaseMutation < GraphQL::Schema::RelayClassicMutation
    argument_class Types::BaseArgument
    field_class Types::BaseField
    input_object_class Types::BaseInputObject
    object_class Types::BaseObject
  end
end
</file>

<file path="app/graphql/resolvers/base_resolver.rb">
# frozen_string_literal: true

module Resolvers
  class BaseResolver < GraphQL::Schema::Resolver
  end
end
</file>

<file path="app/graphql/types/account_type.rb">
# frozen_string_literal: true

module Types
  class AccountType < Types::BaseObject
    field :id, ID, null: false
    field :name, String, null: false
    field :email, String, null: false
    field :phone, String, null: false
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :vertical, Types::VerticalType, null: false

    # Computed fields
    field :display_name_with_vertical, String, null: false
    field :total_customers, Integer, null: false
    field :total_staff, Integer, null: false

    # Business logic fields
    field :cleaning, Boolean, null: false
    field :elderly_care, Boolean, null: false
    field :requires_background_checks, Boolean, null: false

    def cleaning
      object.cleaning?
    end

    def elderly_care
      object.elderly_care?
    end

    def requires_background_checks
      object.requires_background_checks?
    end
  end
end
</file>

<file path="app/graphql/types/appointment_type.rb">
# frozen_string_literal: true

module Types
  class AppointmentType < Types::BaseObject
    field :id, ID, null: false
    field :scheduled_at, GraphQL::Types::ISO8601DateTime, null: false
    field :duration_minutes, Integer, null: false
    field :status, String, null: false
    field :notes, String, null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :account, Types::AccountType, null: false
    field :customer, Types::CustomerType, null: true
    field :service_type, Types::ServiceType, null: false
    field :staff, Types::StaffType, null: true

    # Computed fields
    field :duration_in_hours, String, null: false
    field :end_time, GraphQL::Types::ISO8601DateTime, null: false
    field :is_today, Boolean, null: false
    field :estimated_cost, Float, null: false do
      argument :hourly_rate, Float, required: false, default_value: 50.0
    end

    # Business logic fields
    field :vertical_name, String, null: false
    field :requires_compliance, Boolean, null: false

    def duration_in_hours
      hours = object.duration_minutes / 60.0
      if hours == hours.to_i
        "#{hours.to_i}h"
      else
        "#{hours}h"
      end
    end

    def end_time
      object.scheduled_at + object.duration_minutes.minutes
    end

    def is_today
      object.scheduled_at.to_date == Date.current
    end

    def estimated_cost(hourly_rate:)
      (object.duration_minutes / 60.0 * hourly_rate).round(2)
    end

    def vertical_name
      object.account.vertical.display_name
    end

    def requires_compliance
      object.account.vertical.requires_compliance_tracking?
    end
  end
end
</file>

<file path="app/graphql/types/base_argument.rb">
# frozen_string_literal: true

module Types
  class BaseArgument < GraphQL::Schema::Argument
  end
end
</file>

<file path="app/graphql/types/base_connection.rb">
# frozen_string_literal: true

module Types
  class BaseConnection < Types::BaseObject
    # add `nodes` and `pageInfo` fields, as well as `edge_type(...)` and `node_nullable(...)` overrides
    include GraphQL::Types::Relay::ConnectionBehaviors
  end
end
</file>

<file path="app/graphql/types/base_edge.rb">
# frozen_string_literal: true

module Types
  class BaseEdge < Types::BaseObject
    # add `node` and `cursor` fields, as well as `node_type(...)` override
    include GraphQL::Types::Relay::EdgeBehaviors
  end
end
</file>

<file path="app/graphql/types/base_enum.rb">
# frozen_string_literal: true

module Types
  class BaseEnum < GraphQL::Schema::Enum
  end
end
</file>

<file path="app/graphql/types/base_field.rb">
# frozen_string_literal: true

module Types
  class BaseField < GraphQL::Schema::Field
    argument_class Types::BaseArgument
  end
end
</file>

<file path="app/graphql/types/base_input_object.rb">
# frozen_string_literal: true

module Types
  class BaseInputObject < GraphQL::Schema::InputObject
    argument_class Types::BaseArgument
  end
end
</file>

<file path="app/graphql/types/base_interface.rb">
# frozen_string_literal: true

module Types
  module BaseInterface
    include GraphQL::Schema::Interface
    edge_type_class(Types::BaseEdge)
    connection_type_class(Types::BaseConnection)

    field_class Types::BaseField
  end
end
</file>

<file path="app/graphql/types/base_object.rb">
# frozen_string_literal: true

module Types
  class BaseObject < GraphQL::Schema::Object
    edge_type_class(Types::BaseEdge)
    connection_type_class(Types::BaseConnection)
    field_class Types::BaseField
  end
end
</file>

<file path="app/graphql/types/base_scalar.rb">
# frozen_string_literal: true

module Types
  class BaseScalar < GraphQL::Schema::Scalar
  end
end
</file>

<file path="app/graphql/types/base_union.rb">
# frozen_string_literal: true

module Types
  class BaseUnion < GraphQL::Schema::Union
    edge_type_class(Types::BaseEdge)
    connection_type_class(Types::BaseConnection)
  end
end
</file>

<file path="app/graphql/types/customer_type.rb">
# frozen_string_literal: true

module Types
  class CustomerType < Types::BaseObject
    field :id, ID, null: false
    field :first_name, String, null: false
    field :last_name, String, null: false
    field :email, String, null: false
    field :phone, String, null: false
    field :address, String, null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :account, Types::AccountType, null: false

    # Computed fields
    field :full_name, String, null: false

    def full_name
      "#{object.first_name} #{object.last_name}"
    end
  end
end
</file>

<file path="app/graphql/types/mutation_type.rb">
# frozen_string_literal: true

module Types
  class MutationType < Types::BaseObject
    field :create_appointment, mutation: Mutations::CreateAppointment
  end
end
</file>

<file path="app/graphql/types/node_type.rb">
# frozen_string_literal: true

module Types
  module NodeType
    include Types::BaseInterface
    # Add the `id` field
    include GraphQL::Types::Relay::NodeBehaviors
  end
end
</file>

<file path="app/graphql/types/query_type.rb">
# frozen_string_literal: true

module Types
  class QueryType < Types::BaseObject
    include GraphQL::Types::Relay::HasNodeField
    include GraphQL::Types::Relay::HasNodesField

    # Add root-level fields type by type.

    field :node, Types::NodeType, null: true, description: "Fetches an object given its ID." do
      argument :id, GraphQL::Types::ID, required: true, description: "ID of the object."
    end

    def node(id:)
      context.schema.object_from_id(id, context)
    end

    field :nodes, [Types::NodeType, null: true], null: true, description: "Fetches a list of objects given a list of IDs." do
      argument :ids, [GraphQL::Types::ID], required: true, description: "IDs of the objects."
    end

    def nodes(ids:)
      ids.map { |id| context.schema.object_from_id(id, context) }
    end

    # Our custom fields
    field :verticals, [Types::VerticalType], null: false, description: "Get all available verticals"
    field :vertical, Types::VerticalType, null: true, description: "Get a specific vertical" do
      argument :id, GraphQL::Types::ID, required: false
      argument :slug, String, required: false
    end

    field :accounts, [Types::AccountType], null: false, description: "Get all accounts"
    field :account, Types::AccountType, null: true, description: "Get a specific account" do
      argument :id, GraphQL::Types::ID, required: true
    end

    field :service_types, [Types::ServiceType], null: false, description: "Get all service types"
    field :service_types_for_vertical, [Types::ServiceType], null: false, description: "Get service types for a specific vertical" do
      argument :vertical_id, GraphQL::Types::ID, required: true
    end

    # Resolver methods
    def verticals
      Vertical.active
    end

    def vertical(id: nil, slug: nil)
      if id
        Vertical.find_by(id: id)
      elsif slug
        Vertical.find_by(slug: slug)
      else
        raise GraphQL::ExecutionError, "Must provide either id or slug"
      end
    end

    def accounts
      Account.all
    end

    def account(id:)
      Account.find_by(id: id)
    end

    def service_types
      ServiceType.all
    end

    def service_types_for_vertical(vertical_id:)
      ServiceType.where(vertical_id: vertical_id)
    end
  end
end
</file>

<file path="app/graphql/types/service_type.rb">
# frozen_string_literal: true

module Types
  class ServiceType < Types::BaseObject
    field :id, ID, null: false
    field :name, String, null: false
    field :duration_minutes, Integer, null: false
    field :requires_background_check, Boolean, null: false
    field :min_staff_ratio, Float, null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :vertical, Types::VerticalType, null: false

    # Business logic fields
    field :display_name, String, null: false
    field :duration_in_hours, String, null: false
    field :estimated_cost, Float, null: false do
      argument :hourly_rate, Float, required: false, default_value: 50.0
    end
    field :requires_multiple_staff, Boolean, null: false
    field :compliance_requirements, [String], null: false

    # Delegated methods
    def estimated_cost(hourly_rate:)
      object.estimated_cost(hourly_rate)
    end
  end
end
</file>

<file path="app/graphql/types/staff_type.rb">
# frozen_string_literal: true

module Types
  class StaffType < Types::BaseObject
    field :id, ID, null: false
    field :first_name, String, null: false
    field :last_name, String, null: false
    field :email, String, null: false
    field :phone, String, null: false
    field :background_check_passed, Boolean, null: false
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :account, Types::AccountType, null: false

    # Computed fields
    field :full_name, String, null: false
    field :can_handle_sensitive_services, Boolean, null: false

    def full_name
      "#{object.first_name} #{object.last_name}"
    end

    def can_handle_sensitive_services
      object.background_check_passed
    end
  end
end
</file>

<file path="app/graphql/types/vertical_type.rb">
# frozen_string_literal: true

module Types
  class VerticalType < Types::BaseObject
    field :id, ID, null: false
    field :name, String, null: false
    field :slug, String, null: false
    field :description, String, null: true
    field :active, Boolean, null: false
    field :display_name, String, null: false
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

    # Associations
    field :accounts, [Types::AccountType], null: false
    field :service_types, [Types::ServiceType], null: false

    # Business logic fields
    field :is_cleaning, Boolean, null: false
    field :is_elderly_care, Boolean, null: false
    field :requires_compliance_tracking, Boolean, null: false
    field :requires_background_checks, Boolean, null: false

    # Computed fields
    field :total_accounts, Integer, null: false
    field :total_service_types, Integer, null: false

    def is_cleaning
      object.cleaning?
    end

    def is_elderly_care
      object.elderly_care?
    end

    def requires_compliance_tracking
      object.requires_compliance_tracking?
    end

    def requires_background_checks
      object.requires_background_checks?
    end

    def total_accounts
      object.accounts.count
    end

    def total_service_types
      object.service_types.count
    end
  end
end
</file>

<file path="app/graphql/carestack_schema.rb">
# frozen_string_literal: true

class CarestackSchema < GraphQL::Schema
  mutation(Types::MutationType)
  query(Types::QueryType)

  # For batch-loading (see https://graphql-ruby.org/dataloader/overview.html)
  use GraphQL::Dataloader

  # GraphQL-Ruby calls this when something goes wrong while running a query:
  def self.type_error(err, context)
    # if err.is_a?(GraphQL::InvalidNullError)
    #   # report to your bug tracker here
    #   return nil
    # end
    super
  end

  # Union and Interface Resolution
  def self.resolve_type(abstract_type, obj, ctx)
    # TODO: Implement this method
    # to return the correct GraphQL object type for `obj`
    raise(GraphQL::RequiredImplementationMissingError)
  end

  # Limit the size of incoming queries:
  max_query_string_tokens(5000)

  # Stop validating when it encounters this many errors:
  validate_max_errors(100)

  # Relay-style Object Identification:

  # Return a string UUID for `object`
  def self.id_from_object(object, type_definition, query_ctx)
    # For example, use Rails' GlobalID library (https://github.com/rails/globalid):
    object.to_gid_param
  end

  # Given a string UUID, find the object
  def self.object_from_id(global_id, query_ctx)
    # For example, use Rails' GlobalID library (https://github.com/rails/globalid):
    GlobalID.find(global_id)
  end
end
</file>

<file path="app/jobs/application_job.rb">
class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  # retry_on ActiveRecord::Deadlocked

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError
end
</file>

<file path="app/mailers/application_mailer.rb">
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end
</file>

<file path="app/models/account.rb">
class Account < ApplicationRecord
  # Relationships
  belongs_to :vertical
  has_many :customers, dependent: :destroy
  has_many :staff, dependent: :destroy
  has_many :appointments, dependent: :destroy
  has_many :service_types, through: :vertical

  # Validations
  validates :name, presence: true
  validates :email, presence: true, format: { with: URI::MailTo::EMAIL_REGEXP }
  validates :phone, presence: true

  # Delegations to vertical for cleaner code
  delegate :display_name, to: :vertical, prefix: true
  delegate :requires_compliance_tracking?, to: :vertical
  delegate :requires_background_checks?, to: :vertical
  delegate :cleaning?, to: :vertical
  delegate :elderly_care?, to: :vertical

  # Scopes
  scope :for_vertical, ->(vertical_slug) { joins(:vertical).where(verticals: { slug: vertical_slug }) }
  scope :cleaning_services, -> { for_vertical('cleaning') }
  scope :elderly_care_services, -> { for_vertical('elderly_care') }

  # Instance methods
  def display_name_with_vertical
    "#{name} (#{vertical_display_name})"
  end

  def total_customers
    customers.count
  end

  def total_staff
    staff.count
  end

  def active_appointments
    appointments.where(status: ['scheduled', 'in_progress'])
  end

  def completed_appointments_this_month
    appointments.where(
      status: 'completed',
      scheduled_at: 1.month.ago.beginning_of_month..Time.current
    )
  end

  # Vertical-specific business rules
  def can_schedule_appointment?(service_type, staff_count)
    return false unless service_type.vertical == vertical

    if requires_background_checks?
      return false unless all_staff_background_checked?
    end

    if elderly_care? && service_type.min_staff_ratio.present?
      return staff_count >= service_type.min_staff_ratio
    end

    true
  end

  def compliance_status
    return :not_required unless requires_compliance_tracking?
    
    if elderly_care?
      {
        background_checks: staff.where(background_check_passed: true).count,
        total_staff: staff.count,
        compliance_rate: calculate_compliance_rate
      }
    end
  end

  private

  def all_staff_background_checked?
    staff.where(background_check_passed: false).count == 0
  end

  def calculate_compliance_rate
    return 0.0 if staff.count == 0
    
    (staff.where(background_check_passed: true).count.to_f / staff.count * 100).round(2)
  end
end
</file>

<file path="app/models/application_record.rb">
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end
</file>

<file path="app/models/appointment.rb">
class Appointment < ApplicationRecord
  belongs_to :account
  belongs_to :customer
  belongs_to :service_type
  belongs_to :staff
end
</file>

<file path="app/models/customer.rb">
class Customer < ApplicationRecord
  belongs_to :account
end
</file>

<file path="app/models/service_type.rb">
class ServiceType < ApplicationRecord
  # Relationships
  belongs_to :vertical
  has_many :appointments, dependent: :destroy

  # Validations
  validates :name, presence: true
  validates :duration_minutes, presence: true, numericality: { greater_than: 0 }
  validates :min_staff_ratio, numericality: { greater_than: 0 }, allow_nil: true

  # Scopes
  scope :requiring_background_check, -> { where(requires_background_check: true) }
  scope :for_vertical, ->(vertical_slug) { joins(:vertical).where(verticals: { slug: vertical_slug }) }

  # Delegations
  delegate :cleaning?, :elderly_care?, :requires_compliance_tracking?, to: :vertical

  # Instance methods
  def display_name
    "#{name} (#{duration_in_hours})"
  end

  def duration_in_hours
    hours = duration_minutes / 60.0
    if hours == hours.to_i
      "#{hours.to_i}h"
    else
      "#{hours}h"
    end
  end

  def estimated_cost(hourly_rate = 50.0)
    (duration_minutes / 60.0 * hourly_rate).round(2)
  end

  def requires_multiple_staff?
    min_staff_ratio.present? && min_staff_ratio > 1
  end

  def compliance_requirements
    requirements = []
    
    requirements << "Background check required" if requires_background_check?
    requirements << "Minimum #{min_staff_ratio} staff members" if requires_multiple_staff?
    requirements << "Compliance tracking enabled" if requires_compliance_tracking?
    
    requirements
  end

  # Class methods for creating default service types
  def self.create_defaults_for_vertical(vertical)
    case vertical.slug
    when /cleaning/
      create_cleaning_defaults(vertical)
    when /elderly_care/
      create_elderly_care_defaults(vertical)
    when /tutoring/
      create_tutoring_defaults(vertical)
    end
  end

  private

  def self.create_cleaning_defaults(vertical)
    [
      { name: "Basic House Cleaning", duration_minutes: 120, requires_background_check: false },
      { name: "Deep Cleaning", duration_minutes: 240, requires_background_check: false },
      { name: "Move-in/Move-out Cleaning", duration_minutes: 180, requires_background_check: false },
      { name: "Post-Construction Cleanup", duration_minutes: 300, requires_background_check: true }
    ].each do |attrs|
      vertical.service_types.find_or_create_by(name: attrs[:name]) do |service_type|
        service_type.assign_attributes(attrs)
      end
    end
  end

  def self.create_elderly_care_defaults(vertical)
    [
      { 
        name: "Companion Care", 
        duration_minutes: 240, 
        requires_background_check: true, 
        min_staff_ratio: 1.0 
      },
      { 
        name: "Personal Care Assistance", 
        duration_minutes: 120, 
        requires_background_check: true, 
        min_staff_ratio: 1.0 
      },
      { 
        name: "24-Hour Care", 
        duration_minutes: 1440, 
        requires_background_check: true, 
        min_staff_ratio: 2.0 
      },
      { 
        name: "Medical Appointment Transport", 
        duration_minutes: 180, 
        requires_background_check: true, 
        min_staff_ratio: 1.0 
      }
    ].each do |attrs|
      vertical.service_types.find_or_create_by(name: attrs[:name]) do |service_type|
        service_type.assign_attributes(attrs)
      end
    end
  end

  def self.create_tutoring_defaults(vertical)
    [
      { name: "Elementary Tutoring", duration_minutes: 60, requires_background_check: true },
      { name: "High School Math", duration_minutes: 90, requires_background_check: true },
      { name: "Test Prep (SAT/ACT)", duration_minutes: 120, requires_background_check: true },
      { name: "College Application Help", duration_minutes: 90, requires_background_check: true }
    ].each do |attrs|
      vertical.service_types.find_or_create_by(name: attrs[:name]) do |service_type|
        service_type.assign_attributes(attrs)
      end
    end
  end
end
</file>

<file path="app/models/staff.rb">
class Staff < ApplicationRecord
  belongs_to :account
end
</file>

<file path="app/models/vertical.rb">
class Vertical < ApplicationRecord
  # Relationships
  has_many :accounts, dependent: :destroy
  has_many :service_types, dependent: :destroy

  # Validations
  validates :name, presence: true, uniqueness: true
  validates :slug, presence: true, uniqueness: true, format: { with: /\A[a-z0-9_]+\z/ }

  # Scopes
  scope :active, -> { where(active: true) }

  # Constants for supported verticals
  SUPPORTED_VERTICALS = %w[
    cleaning
    elderly_care
    tutoring
    home_repair
  ].freeze

  # Callbacks
  before_validation :generate_slug, if: -> { slug.blank? && name.present? }
  before_create :set_active_default

  # Instance methods
  def display_name
    name.titleize
  end

  def cleaning?
    slug.include?('cleaning')
  end

  def elderly_care?
    slug.include?('elderly_care')
  end

  def requires_compliance_tracking?
    elderly_care?
  end

  def requires_background_checks?
    elderly_care? || %w[tutoring home_repair].include?(slug)
  end

  private

  def generate_slug
    self.slug = name.downcase.gsub(/[^a-z0-9]+/, '_')
  end

  def set_active_default
    self.active = true if active.nil?
  end
end
</file>

<file path="app/views/layouts/mailer.html.erb">
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>
</file>

<file path="app/views/layouts/mailer.text.erb">
<%= yield %>
</file>

<file path="bin/brakeman">
#!/usr/bin/env ruby
require "rubygems"
require "bundler/setup"

ARGV.unshift("--ensure-latest")

load Gem.bin_path("brakeman", "brakeman")
</file>

<file path="bin/bundle">
#!/usr/bin/env ruby
# frozen_string_literal: true

#
# This file was generated by Bundler.
#
# The application 'bundle' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require "rubygems"

m = Module.new do
  module_function

  def invoked_as_script?
    File.expand_path($0) == File.expand_path(__FILE__)
  end

  def env_var_version
    ENV["BUNDLER_VERSION"]
  end

  def cli_arg_version
    return unless invoked_as_script? # don't want to hijack other binstubs
    return unless "update".start_with?(ARGV.first || " ") # must be running `bundle update`
    bundler_version = nil
    update_index = nil
    ARGV.each_with_index do |a, i|
      if update_index && update_index.succ == i && a =~ Gem::Version::ANCHORED_VERSION_PATTERN
        bundler_version = a
      end
      next unless a =~ /\A--bundler(?:[= ](#{Gem::Version::VERSION_PATTERN}))?\z/
      bundler_version = $1
      update_index = i
    end
    bundler_version
  end

  def gemfile
    gemfile = ENV["BUNDLE_GEMFILE"]
    return gemfile if gemfile && !gemfile.empty?

    File.expand_path("../Gemfile", __dir__)
  end

  def lockfile
    lockfile =
      case File.basename(gemfile)
      when "gems.rb" then gemfile.sub(/\.rb$/, gemfile)
      else "#{gemfile}.lock"
      end
    File.expand_path(lockfile)
  end

  def lockfile_version
    return unless File.file?(lockfile)
    lockfile_contents = File.read(lockfile)
    return unless lockfile_contents =~ /\n\nBUNDLED WITH\n\s{2,}(#{Gem::Version::VERSION_PATTERN})\n/
    Regexp.last_match(1)
  end

  def bundler_requirement
    @bundler_requirement ||=
      env_var_version ||
      cli_arg_version ||
      bundler_requirement_for(lockfile_version)
  end

  def bundler_requirement_for(version)
    return "#{Gem::Requirement.default}.a" unless version

    bundler_gem_version = Gem::Version.new(version)

    bundler_gem_version.approximate_recommendation
  end

  def load_bundler!
    ENV["BUNDLE_GEMFILE"] ||= gemfile

    activate_bundler
  end

  def activate_bundler
    gem_error = activation_error_handling do
      gem "bundler", bundler_requirement
    end
    return if gem_error.nil?
    require_error = activation_error_handling do
      require "bundler/version"
    end
    return if require_error.nil? && Gem::Requirement.new(bundler_requirement).satisfied_by?(Gem::Version.new(Bundler::VERSION))
    warn "Activating bundler (#{bundler_requirement}) failed:\n#{gem_error.message}\n\nTo install the version of bundler this project requires, run `gem install bundler -v '#{bundler_requirement}'`"
    exit 42
  end

  def activation_error_handling
    yield
    nil
  rescue StandardError, LoadError => e
    e
  end
end

m.load_bundler!

if m.invoked_as_script?
  load Gem.bin_path("bundler", "bundle")
end
</file>

<file path="bin/dev">
#!/usr/bin/env ruby
exec "./bin/rails", "server", *ARGV
</file>

<file path="bin/docker-entrypoint">
#!/bin/bash -e

# Enable jemalloc for reduced memory usage and latency.
if [ -z "${LD_PRELOAD+x}" ]; then
    LD_PRELOAD=$(find /usr/lib -name libjemalloc.so.2 -print -quit)
    export LD_PRELOAD
fi

# If running the rails server then create or migrate existing database
if [ "${@: -2:1}" == "./bin/rails" ] && [ "${@: -1:1}" == "server" ]; then
  ./bin/rails db:prepare
fi

exec "${@}"
</file>

<file path="bin/jobs">
#!/usr/bin/env ruby

require_relative "../config/environment"
require "solid_queue/cli"

SolidQueue::Cli.start(ARGV)
</file>

<file path="bin/kamal">
#!/usr/bin/env ruby
# frozen_string_literal: true

#
# This file was generated by Bundler.
#
# The application 'kamal' is installed as part of a gem, and
# this file is here to facilitate running it.
#

ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../Gemfile", __dir__)

bundle_binstub = File.expand_path("bundle", __dir__)

if File.file?(bundle_binstub)
  if File.read(bundle_binstub, 300).include?("This file was generated by Bundler")
    load(bundle_binstub)
  else
    abort("Your `bin/bundle` was not generated by Bundler, so this binstub cannot run.
Replace `bin/bundle` by running `bundle binstubs bundler --force`, then run this command again.")
  end
end

require "rubygems"
require "bundler/setup"

load Gem.bin_path("kamal", "kamal")
</file>

<file path="bin/rails">
#!/usr/bin/env ruby
APP_PATH = File.expand_path("../config/application", __dir__)
require_relative "../config/boot"
require "rails/commands"
</file>

<file path="bin/rake">
#!/usr/bin/env ruby
require_relative "../config/boot"
require "rake"
Rake.application.run
</file>

<file path="bin/rubocop">
#!/usr/bin/env ruby
require "rubygems"
require "bundler/setup"

# explicit rubocop config increases performance slightly while avoiding config confusion.
ARGV.unshift("--config", File.expand_path("../.rubocop.yml", __dir__))

load Gem.bin_path("rubocop", "rubocop")
</file>

<file path="bin/setup">
#!/usr/bin/env ruby
require "fileutils"

APP_ROOT = File.expand_path("..", __dir__)

def system!(*args)
  system(*args, exception: true)
end

FileUtils.chdir APP_ROOT do
  # This script is a way to set up or update your development environment automatically.
  # This script is idempotent, so that you can run it at any time and get an expectable outcome.
  # Add necessary setup steps to this file.

  puts "== Installing dependencies =="
  system("bundle check") || system!("bundle install")

  # puts "\n== Copying sample files =="
  # unless File.exist?("config/database.yml")
  #   FileUtils.cp "config/database.yml.sample", "config/database.yml"
  # end

  puts "\n== Preparing database =="
  system! "bin/rails db:prepare"

  puts "\n== Removing old logs and tempfiles =="
  system! "bin/rails log:clear tmp:clear"

  unless ARGV.include?("--skip-server")
    puts "\n== Starting development server =="
    STDOUT.flush # flush the output before exec(2) so that it displays
    exec "bin/dev"
  end
end
</file>

<file path="bin/thrust">
#!/usr/bin/env ruby
require "rubygems"
require "bundler/setup"

load Gem.bin_path("thruster", "thrust")
</file>

<file path="config/environments/development.rb">
require "active_support/core_ext/integer/time"

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # Make code changes take effect immediately without server restart.
  config.enable_reloading = true

  # Do not eager load code on boot.
  config.eager_load = false

  # Show full error reports.
  config.consider_all_requests_local = true

  # Enable server timing.
  config.server_timing = true

  # Enable/disable Action Controller caching. By default Action Controller caching is disabled.
  # Run rails dev:cache to toggle Action Controller caching.
  if Rails.root.join("tmp/caching-dev.txt").exist?
    config.public_file_server.headers = { "cache-control" => "public, max-age=#{2.days.to_i}" }
  else
    config.action_controller.perform_caching = false
  end

  # Change to :null_store to avoid any caching.
  config.cache_store = :memory_store

  # Store uploaded files on the local file system (see config/storage.yml for options).
  config.active_storage.service = :local

  # Don't care if the mailer can't send.
  config.action_mailer.raise_delivery_errors = false

  # Make template changes take effect immediately.
  config.action_mailer.perform_caching = false

  # Set localhost to be used by links generated in mailer templates.
  config.action_mailer.default_url_options = { host: "localhost", port: 3000 }

  # Print deprecation notices to the Rails logger.
  config.active_support.deprecation = :log

  # Raise an error on page load if there are pending migrations.
  config.active_record.migration_error = :page_load

  # Highlight code that triggered database queries in logs.
  config.active_record.verbose_query_logs = true

  # Append comments with runtime information tags to SQL queries in logs.
  config.active_record.query_log_tags_enabled = true

  # Highlight code that enqueued background job in logs.
  config.active_job.verbose_enqueue_logs = true

  # Raises error for missing translations.
  # config.i18n.raise_on_missing_translations = true

  # Annotate rendered view with file names.
  config.action_view.annotate_rendered_view_with_filenames = true

  # Uncomment if you wish to allow Action Cable access from any origin.
  # config.action_cable.disable_request_forgery_protection = true

  # Raise error when a before_action's only/except options reference missing actions.
  config.action_controller.raise_on_missing_callback_actions = true

  # Apply autocorrection by RuboCop to files generated by `bin/rails generate`.
  # config.generators.apply_rubocop_autocorrect_after_generate!
end
</file>

<file path="config/environments/production.rb">
require "active_support/core_ext/integer/time"

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # Code is not reloaded between requests.
  config.enable_reloading = false

  # Eager load code on boot for better performance and memory savings (ignored by Rake tasks).
  config.eager_load = true

  # Full error reports are disabled.
  config.consider_all_requests_local = false

  # Cache assets for far-future expiry since they are all digest stamped.
  config.public_file_server.headers = { "cache-control" => "public, max-age=#{1.year.to_i}" }

  # Enable serving of images, stylesheets, and JavaScripts from an asset server.
  # config.asset_host = "http://assets.example.com"

  # Store uploaded files on the local file system (see config/storage.yml for options).
  config.active_storage.service = :local

  # Assume all access to the app is happening through a SSL-terminating reverse proxy.
  config.assume_ssl = true

  # Force all access to the app over SSL, use Strict-Transport-Security, and use secure cookies.
  config.force_ssl = true

  # Skip http-to-https redirect for the default health check endpoint.
  # config.ssl_options = { redirect: { exclude: ->(request) { request.path == "/up" } } }

  # Log to STDOUT with the current request id as a default log tag.
  config.log_tags = [ :request_id ]
  config.logger   = ActiveSupport::TaggedLogging.logger(STDOUT)

  # Change to "debug" to log everything (including potentially personally-identifiable information!)
  config.log_level = ENV.fetch("RAILS_LOG_LEVEL", "info")

  # Prevent health checks from clogging up the logs.
  config.silence_healthcheck_path = "/up"

  # Don't log any deprecations.
  config.active_support.report_deprecations = false

  # Replace the default in-process memory cache store with a durable alternative.
  config.cache_store = :solid_cache_store

  # Replace the default in-process and non-durable queuing backend for Active Job.
  config.active_job.queue_adapter = :solid_queue
  config.solid_queue.connects_to = { database: { writing: :queue } }

  # Ignore bad email addresses and do not raise email delivery errors.
  # Set this to true and configure the email server for immediate delivery to raise delivery errors.
  # config.action_mailer.raise_delivery_errors = false

  # Set host to be used by links generated in mailer templates.
  config.action_mailer.default_url_options = { host: "example.com" }

  # Specify outgoing SMTP server. Remember to add smtp/* credentials via rails credentials:edit.
  # config.action_mailer.smtp_settings = {
  #   user_name: Rails.application.credentials.dig(:smtp, :user_name),
  #   password: Rails.application.credentials.dig(:smtp, :password),
  #   address: "smtp.example.com",
  #   port: 587,
  #   authentication: :plain
  # }

  # Enable locale fallbacks for I18n (makes lookups for any locale fall back to
  # the I18n.default_locale when a translation cannot be found).
  config.i18n.fallbacks = true

  # Do not dump schema after migrations.
  config.active_record.dump_schema_after_migration = false

  # Only use :id for inspections in production.
  config.active_record.attributes_for_inspect = [ :id ]

  # Enable DNS rebinding protection and other `Host` header attacks.
  # config.hosts = [
  #   "example.com",     # Allow requests from example.com
  #   /.*\.example\.com/ # Allow requests from subdomains like `www.example.com`
  # ]
  #
  # Skip DNS rebinding protection for the default health check endpoint.
  # config.host_authorization = { exclude: ->(request) { request.path == "/up" } }
end
</file>

<file path="config/environments/test.rb">
# The test environment is used exclusively to run your application's
# test suite. You never need to work with it otherwise. Remember that
# your test database is "scratch space" for the test suite and is wiped
# and recreated between test runs. Don't rely on the data there!

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # While tests run files are not watched, reloading is not necessary.
  config.enable_reloading = false

  # Eager loading loads your entire application. When running a single test locally,
  # this is usually not necessary, and can slow down your test suite. However, it's
  # recommended that you enable it in continuous integration systems to ensure eager
  # loading is working properly before deploying your code.
  config.eager_load = ENV["CI"].present?

  # Configure public file server for tests with cache-control for performance.
  config.public_file_server.headers = { "cache-control" => "public, max-age=3600" }

  # Show full error reports.
  config.consider_all_requests_local = true
  config.cache_store = :null_store

  # Render exception templates for rescuable exceptions and raise for other exceptions.
  config.action_dispatch.show_exceptions = :rescuable

  # Disable request forgery protection in test environment.
  config.action_controller.allow_forgery_protection = false

  # Store uploaded files on the local file system in a temporary directory.
  config.active_storage.service = :test

  # Tell Action Mailer not to deliver emails to the real world.
  # The :test delivery method accumulates sent emails in the
  # ActionMailer::Base.deliveries array.
  config.action_mailer.delivery_method = :test

  # Set host to be used by links generated in mailer templates.
  config.action_mailer.default_url_options = { host: "example.com" }

  # Print deprecation notices to the stderr.
  config.active_support.deprecation = :stderr

  # Raises error for missing translations.
  # config.i18n.raise_on_missing_translations = true

  # Annotate rendered view with file names.
  # config.action_view.annotate_rendered_view_with_filenames = true

  # Raise error when a before_action's only/except options reference missing actions.
  config.action_controller.raise_on_missing_callback_actions = true
end
</file>

<file path="config/initializers/cors.rb">
# Be sure to restart your server when you modify this file.

# Avoid CORS issues when API is called from the frontend app.
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin Ajax requests.

# Read more: https://github.com/cyu/rack-cors

# Rails.application.config.middleware.insert_before 0, Rack::Cors do
#   allow do
#     origins "example.com"
#
#     resource "*",
#       headers: :any,
#       methods: [:get, :post, :put, :patch, :delete, :options, :head]
#   end
# end
</file>

<file path="config/initializers/filter_parameter_logging.rb">
# Be sure to restart your server when you modify this file.

# Configure parameters to be partially matched (e.g. passw matches password) and filtered from the log file.
# Use this to limit dissemination of sensitive information.
# See the ActiveSupport::ParameterFilter documentation for supported notations and behaviors.
Rails.application.config.filter_parameters += [
  :passw, :email, :secret, :token, :_key, :crypt, :salt, :certificate, :otp, :ssn, :cvv, :cvc
]
</file>

<file path="config/initializers/inflections.rb">
# Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, "\\1en"
#   inflect.singular /^(ox)en/i, "\\1"
#   inflect.irregular "person", "people"
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym "RESTful"
# end
</file>

<file path="config/locales/en.yml">
# Files in the config/locales directory are used for internationalization and
# are automatically loaded by Rails. If you want to use locales other than
# English, add the necessary files in this directory.
#
# To use the locales, use `I18n.t`:
#
#     I18n.t "hello"
#
# In views, this is aliased to just `t`:
#
#     <%= t("hello") %>
#
# To use a different locale, set it with `I18n.locale`:
#
#     I18n.locale = :es
#
# This would use the information in config/locales/es.yml.
#
# To learn more about the API, please read the Rails Internationalization guide
# at https://guides.rubyonrails.org/i18n.html.
#
# Be aware that YAML interprets the following case-insensitive strings as
# booleans: `true`, `false`, `on`, `off`, `yes`, `no`. Therefore, these strings
# must be quoted to be interpreted as strings. For example:
#
#     en:
#       "yes": yup
#       enabled: "ON"

en:
  hello: "Hello world"
</file>

<file path="config/boot.rb">
ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../Gemfile", __dir__)

require "bundler/setup" # Set up gems listed in the Gemfile.
</file>

<file path="config/cable.yml">
# Async adapter only works within the same process, so for manually triggering cable updates from a console,
# and seeing results in the browser, you must do so from the web console (running inside the dev process),
# not a terminal started via bin/rails console! Add "console" to any action or any ERB template view
# to make the web console appear.
development:
  adapter: async

test:
  adapter: test

production:
  adapter: solid_cable
  connects_to:
    database:
      writing: cable
  polling_interval: 0.1.seconds
  message_retention: 1.day
</file>

<file path="config/cache.yml">
default: &default
  store_options:
    # Cap age of oldest cache entry to fulfill retention policies
    # max_age: <%= 60.days.to_i %>
    max_size: <%= 256.megabytes %>
    namespace: <%= Rails.env %>

development:
  <<: *default

test:
  <<: *default

production:
  database: cache
  <<: *default
</file>

<file path="config/credentials.yml.enc">
1orVU7caZnVgRCJogBhK3Wd/TQ6nwvGde1Dn+fOTQC6AHwGF3YfVouF+wAJcT0jObvFXAVgh6vGZYI3Zkkb4jiyyH+pd3TSOPl5efQ2PPkffvdiUOUxz6NbfFtOFzF6zvogvIlbpHYwj8lHQ/uIkVE3Q83uMpnwaNdUwrDj7WTMh+MvVWwO4DQnfiXxxAElsU2QUbPwScj5yUxQ5JxLNEIHCgOBziuZ79eyTIDSfIgzhDjbtFIIYeCNtKytAMC2JGdx7BLEArjOCicX3Zy/bzrqw4MOIERzKgnGcIK5Z4L6/wUBlvYQh3jyD7qLqwxj9U5YfaVVa0lKPXWb+puvNn3fBuFs8KRz9P3nW0v2k5+3rEt4ZDLkv6ZL1vdKDT2q3v0mgZBKVrvndyZeOxZ6bdhQgVLmTi0pusa1smzqtFC0AtwQsjY4gOA4B/HlXP5hGTsjwR9e27qxxN9j0Ta2w6qQC4Zx4xl61plPKSf1sas8t3YLokbYaEV/6--uOTuNxMJNwLiQJq1--53S9FKCvVoPndT0L2rdu4w==
</file>

<file path="config/database.yml">
# PostgreSQL. Versions 9.3 and up are supported.
#
# Install the pg driver:
#   gem install pg
# On macOS with Homebrew:
#   gem install pg -- --with-pg-config=/usr/local/bin/pg_config
# On Windows:
#   gem install pg
#       Choose the win32 build.
#       Install PostgreSQL and put its /bin directory on your path.
#
# Configure Using Gemfile
# gem "pg"
#
default: &default
  adapter: postgresql
  encoding: unicode
  # For details on connection pooling, see Rails configuration guide
  # https://guides.rubyonrails.org/configuring.html#database-pooling
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>


development:
  <<: *default
  database: carestack_development

  # The specified database role being used to connect to PostgreSQL.
  # To create additional roles in PostgreSQL see `$ createuser --help`.
  # When left blank, PostgreSQL will use the default role. This is
  # the same name as the operating system user running Rails.
  #username: carestack

  # The password associated with the PostgreSQL role (username).
  #password:

  # Connect on a TCP socket. Omitted by default since the client uses a
  # domain socket that doesn't need configuration. Windows does not have
  # domain sockets, so uncomment these lines.
  #host: localhost

  # The TCP port the server listens on. Defaults to 5432.
  # If your server runs on a different port number, change accordingly.
  #port: 5432

  # Schema search path. The server defaults to $user,public
  #schema_search_path: myapp,sharedapp,public

  # Minimum log levels, in increasing order:
  #   debug5, debug4, debug3, debug2, debug1,
  #   log, notice, warning, error, fatal, and panic
  # Defaults to warning.
  #min_messages: notice

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  <<: *default
  database: carestack_test

# As with config/credentials.yml, you never want to store sensitive information,
# like your database password, in your source code. If your source code is
# ever seen by anyone, they now have access to your database.
#
# Instead, provide the password or a full connection URL as an environment
# variable when you boot the app. For example:
#
#   DATABASE_URL="postgres://myuser:mypass@localhost/somedatabase"
#
# If the connection URL is provided in the special DATABASE_URL environment
# variable, Rails will automatically merge its configuration values on top of
# the values provided in this file. Alternatively, you can specify a connection
# URL environment variable explicitly:
#
#   production:
#     url: <%= ENV["MY_APP_DATABASE_URL"] %>
#
# Read https://guides.rubyonrails.org/configuring.html#configuring-a-database
# for a full overview on how database connection configuration can be specified.
#
production:
  primary: &primary_production
    <<: *default
    database: carestack_production
    username: carestack
    password: <%= ENV["CARESTACK_DATABASE_PASSWORD"] %>
  cache:
    <<: *primary_production
    database: carestack_production_cache
    migrations_paths: db/cache_migrate
  queue:
    <<: *primary_production
    database: carestack_production_queue
    migrations_paths: db/queue_migrate
  cable:
    <<: *primary_production
    database: carestack_production_cable
    migrations_paths: db/cable_migrate
</file>

<file path="config/deploy.yml">
# Name of your application. Used to uniquely configure containers.
service: carestack

# Name of the container image.
image: your-user/carestack

# Deploy to these servers.
servers:
  web:
    - 192.168.0.1
  # job:
  #   hosts:
  #     - 192.168.0.1
  #   cmd: bin/jobs

# Enable SSL auto certification via Let's Encrypt and allow for multiple apps on a single web server.
# Remove this section when using multiple web servers and ensure you terminate SSL at your load balancer.
#
# Note: If using Cloudflare, set encryption mode in SSL/TLS setting to "Full" to enable CF-to-app encryption.
proxy:
  ssl: true
  host: app.example.com

# Credentials for your image host.
registry:
  # Specify the registry server, if you're not using Docker Hub
  # server: registry.digitalocean.com / ghcr.io / ...
  username: your-user

  # Always use an access token rather than real password when possible.
  password:
    - KAMAL_REGISTRY_PASSWORD

# Inject ENV variables into containers (secrets come from .kamal/secrets).
env:
  secret:
    - RAILS_MASTER_KEY
  clear:
    # Run the Solid Queue Supervisor inside the web server's Puma process to do jobs.
    # When you start using multiple servers, you should split out job processing to a dedicated machine.
    SOLID_QUEUE_IN_PUMA: true

    # Set number of processes dedicated to Solid Queue (default: 1)
    # JOB_CONCURRENCY: 3

    # Set number of cores available to the application on each server (default: 1).
    # WEB_CONCURRENCY: 2

    # Match this to any external database server to configure Active Record correctly
    # Use carestack-db for a db accessory server on same machine via local kamal docker network.
    # DB_HOST: 192.168.0.2

    # Log everything from Rails
    # RAILS_LOG_LEVEL: debug

# Aliases are triggered with "bin/kamal <alias>". You can overwrite arguments on invocation:
# "bin/kamal logs -r job" will tail logs from the first server in the job section.
aliases:
  console: app exec --interactive --reuse "bin/rails console"
  shell: app exec --interactive --reuse "bash"
  logs: app logs -f
  dbc: app exec --interactive --reuse "bin/rails dbconsole"


# Use a persistent storage volume for sqlite database files and local Active Storage files.
# Recommended to change this to a mounted volume path that is backed up off server.
volumes:
  - "carestack_storage:/rails/storage"


# Bridge fingerprinted assets, like JS and CSS, between versions to avoid
# hitting 404 on in-flight requests. Combines all files from new and old
# version inside the asset_path.
asset_path: /rails/public/assets

# Configure the image builder.
builder:
  arch: amd64

  # # Build image via remote server (useful for faster amd64 builds on arm64 computers)
  # remote: ssh://docker@docker-builder-server
  #
  # # Pass arguments and secrets to the Docker build process
  # args:
  #   RUBY_VERSION: 3.2.0
  # secrets:
  #   - GITHUB_TOKEN
  #   - RAILS_MASTER_KEY

# Use a different ssh user than root
# ssh:
#   user: app

# Use accessory services (secrets come from .kamal/secrets).
# accessories:
#   db:
#     image: mysql:8.0
#     host: 192.168.0.2
#     # Change to 3306 to expose port to the world instead of just local network.
#     port: "127.0.0.1:3306:3306"
#     env:
#       clear:
#         MYSQL_ROOT_HOST: '%'
#       secret:
#         - MYSQL_ROOT_PASSWORD
#     files:
#       - config/mysql/production.cnf:/etc/mysql/my.cnf
#       - db/production.sql:/docker-entrypoint-initdb.d/setup.sql
#     directories:
#       - data:/var/lib/mysql
#   redis:
#     image: redis:7.0
#     host: 192.168.0.2
#     port: 6379
#     directories:
#       - data:/data
</file>

<file path="config/environment.rb">
# Load the Rails application.
require_relative "application"

# Initialize the Rails application.
Rails.application.initialize!
</file>

<file path="config/puma.rb">
# This configuration file will be evaluated by Puma. The top-level methods that
# are invoked here are part of Puma's configuration DSL. For more information
# about methods provided by the DSL, see https://puma.io/puma/Puma/DSL.html.
#
# Puma starts a configurable number of processes (workers) and each process
# serves each request in a thread from an internal thread pool.
#
# You can control the number of workers using ENV["WEB_CONCURRENCY"]. You
# should only set this value when you want to run 2 or more workers. The
# default is already 1.
#
# The ideal number of threads per worker depends both on how much time the
# application spends waiting for IO operations and on how much you wish to
# prioritize throughput over latency.
#
# As a rule of thumb, increasing the number of threads will increase how much
# traffic a given process can handle (throughput), but due to CRuby's
# Global VM Lock (GVL) it has diminishing returns and will degrade the
# response time (latency) of the application.
#
# The default is set to 3 threads as it's deemed a decent compromise between
# throughput and latency for the average Rails application.
#
# Any libraries that use a connection pool or another resource pool should
# be configured to provide at least as many connections as the number of
# threads. This includes Active Record's `pool` parameter in `database.yml`.
threads_count = ENV.fetch("RAILS_MAX_THREADS", 3)
threads threads_count, threads_count

# Specifies the `port` that Puma will listen on to receive requests; default is 3000.
port ENV.fetch("PORT", 3000)

# Allow puma to be restarted by `bin/rails restart` command.
plugin :tmp_restart

# Run the Solid Queue supervisor inside of Puma for single-server deployments
plugin :solid_queue if ENV["SOLID_QUEUE_IN_PUMA"]

# Specify the PID file. Defaults to tmp/pids/server.pid in development.
# In other environments, only set the PID file if requested.
pidfile ENV["PIDFILE"] if ENV["PIDFILE"]
</file>

<file path="config/queue.yml">
default: &default
  dispatchers:
    - polling_interval: 1
      batch_size: 500
  workers:
    - queues: "*"
      threads: 3
      processes: <%= ENV.fetch("JOB_CONCURRENCY", 1) %>
      polling_interval: 0.1

development:
  <<: *default

test:
  <<: *default

production:
  <<: *default
</file>

<file path="config/recurring.yml">
# examples:
#   periodic_cleanup:
#     class: CleanSoftDeletedRecordsJob
#     queue: background
#     args: [ 1000, { batch_size: 500 } ]
#     schedule: every hour
#   periodic_cleanup_with_command:
#     command: "SoftDeletedRecord.due.delete_all"
#     priority: 2
#     schedule: at 5am every day

production:
  clear_solid_queue_finished_jobs:
    command: "SolidQueue::Job.clear_finished_in_batches(sleep_between_batches: 0.3)"
    schedule: every hour at minute 12
</file>

<file path="config/storage.yml">
test:
  service: Disk
  root: <%= Rails.root.join("tmp/storage") %>

local:
  service: Disk
  root: <%= Rails.root.join("storage") %>

# Use bin/rails credentials:edit to set the AWS secrets (as aws:access_key_id|secret_access_key)
# amazon:
#   service: S3
#   access_key_id: <%= Rails.application.credentials.dig(:aws, :access_key_id) %>
#   secret_access_key: <%= Rails.application.credentials.dig(:aws, :secret_access_key) %>
#   region: us-east-1
#   bucket: your_own_bucket-<%= Rails.env %>

# Remember not to checkin your GCS keyfile to a repository
# google:
#   service: GCS
#   project: your_project
#   credentials: <%= Rails.root.join("path/to/gcs.keyfile") %>
#   bucket: your_own_bucket-<%= Rails.env %>

# Use bin/rails credentials:edit to set the Azure Storage secret (as azure_storage:storage_access_key)
# microsoft:
#   service: AzureStorage
#   storage_account_name: your_account_name
#   storage_access_key: <%= Rails.application.credentials.dig(:azure_storage, :storage_access_key) %>
#   container: your_container_name-<%= Rails.env %>

# mirror:
#   service: Mirror
#   primary: local
#   mirrors: [ amazon, google, microsoft ]
</file>

<file path="db/migrate/20250831202143_create_verticals.rb">
class CreateVerticals < ActiveRecord::Migration[8.0]
  def change
    create_table :verticals do |t|
      t.string :name
      t.string :slug
      t.text :description
      t.boolean :active

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250831202159_create_accounts.rb">
class CreateAccounts < ActiveRecord::Migration[8.0]
  def change
    create_table :accounts do |t|
      t.string :name
      t.references :vertical, null: false, foreign_key: true
      t.string :email
      t.string :phone

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250831202216_create_service_types.rb">
class CreateServiceTypes < ActiveRecord::Migration[8.0]
  def change
    create_table :service_types do |t|
      t.string :name
      t.references :vertical, null: false, foreign_key: true
      t.integer :duration_minutes
      t.boolean :requires_background_check
      t.decimal :min_staff_ratio

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250831202229_create_customers.rb">
class CreateCustomers < ActiveRecord::Migration[8.0]
  def change
    create_table :customers do |t|
      t.references :account, null: false, foreign_key: true
      t.string :first_name
      t.string :last_name
      t.string :email
      t.string :phone
      t.text :address

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250831202241_create_staffs.rb">
class CreateStaffs < ActiveRecord::Migration[8.0]
  def change
    create_table :staffs do |t|
      t.references :account, null: false, foreign_key: true
      t.string :first_name
      t.string :last_name
      t.string :email
      t.string :phone
      t.boolean :background_check_passed

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250831202253_create_appointments.rb">
class CreateAppointments < ActiveRecord::Migration[8.0]
  def change
    create_table :appointments do |t|
      t.references :account, null: false, foreign_key: true
      t.references :customer, null: false, foreign_key: true
      t.references :service_type, null: false, foreign_key: true
      t.references :staff, null: false, foreign_key: true
      t.datetime :scheduled_at
      t.integer :duration_minutes
      t.string :status
      t.text :notes

      t.timestamps
    end
  end
end
</file>

<file path="db/migrate/20250831213446_create_flipper_tables.rb">
class CreateFlipperTables < ActiveRecord::Migration[8.0]
  def up
    create_table :flipper_features do |t|
      t.string :key, null: false
      t.timestamps null: false
    end
    add_index :flipper_features, :key, unique: true

    create_table :flipper_gates do |t|
      t.string :feature_key, null: false
      t.string :key, null: false
      t.text :value
      t.timestamps null: false
    end
    add_index :flipper_gates, [:feature_key, :key, :value], unique: true, length: { value: 255 }
  end

  def down
    drop_table :flipper_gates
    drop_table :flipper_features
  end
end
</file>

<file path="db/cable_schema.rb">
ActiveRecord::Schema[7.1].define(version: 1) do
  create_table "solid_cable_messages", force: :cascade do |t|
    t.binary "channel", limit: 1024, null: false
    t.binary "payload", limit: 536870912, null: false
    t.datetime "created_at", null: false
    t.integer "channel_hash", limit: 8, null: false
    t.index ["channel"], name: "index_solid_cable_messages_on_channel"
    t.index ["channel_hash"], name: "index_solid_cable_messages_on_channel_hash"
    t.index ["created_at"], name: "index_solid_cable_messages_on_created_at"
  end
end
</file>

<file path="db/cache_schema.rb">
# frozen_string_literal: true

ActiveRecord::Schema[7.2].define(version: 1) do
  create_table "solid_cache_entries", force: :cascade do |t|
    t.binary "key", limit: 1024, null: false
    t.binary "value", limit: 536870912, null: false
    t.datetime "created_at", null: false
    t.integer "key_hash", limit: 8, null: false
    t.integer "byte_size", limit: 4, null: false
    t.index ["byte_size"], name: "index_solid_cache_entries_on_byte_size"
    t.index ["key_hash", "byte_size"], name: "index_solid_cache_entries_on_key_hash_and_byte_size"
    t.index ["key_hash"], name: "index_solid_cache_entries_on_key_hash", unique: true
  end
end
</file>

<file path="db/queue_schema.rb">
ActiveRecord::Schema[7.1].define(version: 1) do
  create_table "solid_queue_blocked_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.string "queue_name", null: false
    t.integer "priority", default: 0, null: false
    t.string "concurrency_key", null: false
    t.datetime "expires_at", null: false
    t.datetime "created_at", null: false
    t.index [ "concurrency_key", "priority", "job_id" ], name: "index_solid_queue_blocked_executions_for_release"
    t.index [ "expires_at", "concurrency_key" ], name: "index_solid_queue_blocked_executions_for_maintenance"
    t.index [ "job_id" ], name: "index_solid_queue_blocked_executions_on_job_id", unique: true
  end

  create_table "solid_queue_claimed_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.bigint "process_id"
    t.datetime "created_at", null: false
    t.index [ "job_id" ], name: "index_solid_queue_claimed_executions_on_job_id", unique: true
    t.index [ "process_id", "job_id" ], name: "index_solid_queue_claimed_executions_on_process_id_and_job_id"
  end

  create_table "solid_queue_failed_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.text "error"
    t.datetime "created_at", null: false
    t.index [ "job_id" ], name: "index_solid_queue_failed_executions_on_job_id", unique: true
  end

  create_table "solid_queue_jobs", force: :cascade do |t|
    t.string "queue_name", null: false
    t.string "class_name", null: false
    t.text "arguments"
    t.integer "priority", default: 0, null: false
    t.string "active_job_id"
    t.datetime "scheduled_at"
    t.datetime "finished_at"
    t.string "concurrency_key"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index [ "active_job_id" ], name: "index_solid_queue_jobs_on_active_job_id"
    t.index [ "class_name" ], name: "index_solid_queue_jobs_on_class_name"
    t.index [ "finished_at" ], name: "index_solid_queue_jobs_on_finished_at"
    t.index [ "queue_name", "finished_at" ], name: "index_solid_queue_jobs_for_filtering"
    t.index [ "scheduled_at", "finished_at" ], name: "index_solid_queue_jobs_for_alerting"
  end

  create_table "solid_queue_pauses", force: :cascade do |t|
    t.string "queue_name", null: false
    t.datetime "created_at", null: false
    t.index [ "queue_name" ], name: "index_solid_queue_pauses_on_queue_name", unique: true
  end

  create_table "solid_queue_processes", force: :cascade do |t|
    t.string "kind", null: false
    t.datetime "last_heartbeat_at", null: false
    t.bigint "supervisor_id"
    t.integer "pid", null: false
    t.string "hostname"
    t.text "metadata"
    t.datetime "created_at", null: false
    t.string "name", null: false
    t.index [ "last_heartbeat_at" ], name: "index_solid_queue_processes_on_last_heartbeat_at"
    t.index [ "name", "supervisor_id" ], name: "index_solid_queue_processes_on_name_and_supervisor_id", unique: true
    t.index [ "supervisor_id" ], name: "index_solid_queue_processes_on_supervisor_id"
  end

  create_table "solid_queue_ready_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.string "queue_name", null: false
    t.integer "priority", default: 0, null: false
    t.datetime "created_at", null: false
    t.index [ "job_id" ], name: "index_solid_queue_ready_executions_on_job_id", unique: true
    t.index [ "priority", "job_id" ], name: "index_solid_queue_poll_all"
    t.index [ "queue_name", "priority", "job_id" ], name: "index_solid_queue_poll_by_queue"
  end

  create_table "solid_queue_recurring_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.string "task_key", null: false
    t.datetime "run_at", null: false
    t.datetime "created_at", null: false
    t.index [ "job_id" ], name: "index_solid_queue_recurring_executions_on_job_id", unique: true
    t.index [ "task_key", "run_at" ], name: "index_solid_queue_recurring_executions_on_task_key_and_run_at", unique: true
  end

  create_table "solid_queue_recurring_tasks", force: :cascade do |t|
    t.string "key", null: false
    t.string "schedule", null: false
    t.string "command", limit: 2048
    t.string "class_name"
    t.text "arguments"
    t.string "queue_name"
    t.integer "priority", default: 0
    t.boolean "static", default: true, null: false
    t.text "description"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index [ "key" ], name: "index_solid_queue_recurring_tasks_on_key", unique: true
    t.index [ "static" ], name: "index_solid_queue_recurring_tasks_on_static"
  end

  create_table "solid_queue_scheduled_executions", force: :cascade do |t|
    t.bigint "job_id", null: false
    t.string "queue_name", null: false
    t.integer "priority", default: 0, null: false
    t.datetime "scheduled_at", null: false
    t.datetime "created_at", null: false
    t.index [ "job_id" ], name: "index_solid_queue_scheduled_executions_on_job_id", unique: true
    t.index [ "scheduled_at", "priority", "job_id" ], name: "index_solid_queue_dispatch_all"
  end

  create_table "solid_queue_semaphores", force: :cascade do |t|
    t.string "key", null: false
    t.integer "value", default: 1, null: false
    t.datetime "expires_at", null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index [ "expires_at" ], name: "index_solid_queue_semaphores_on_expires_at"
    t.index [ "key", "value" ], name: "index_solid_queue_semaphores_on_key_and_value"
    t.index [ "key" ], name: "index_solid_queue_semaphores_on_key", unique: true
  end

  add_foreign_key "solid_queue_blocked_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
  add_foreign_key "solid_queue_claimed_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
  add_foreign_key "solid_queue_failed_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
  add_foreign_key "solid_queue_ready_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
  add_foreign_key "solid_queue_recurring_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
  add_foreign_key "solid_queue_scheduled_executions", "solid_queue_jobs", column: "job_id", on_delete: :cascade
end
</file>

<file path="db/schema.rb">
# This file is auto-generated from the current state of the database. Instead
# of editing this file, please use the migrations feature of Active Record to
# incrementally modify your database, and then regenerate this schema definition.
#
# This file is the source Rails uses to define your schema when running `bin/rails
# db:schema:load`. When creating a new database, `bin/rails db:schema:load` tends to
# be faster and is potentially less error prone than running all of your
# migrations from scratch. Old migrations may fail to apply correctly if those
# migrations use external dependencies or application code.
#
# It's strongly recommended that you check this file into your version control system.

ActiveRecord::Schema[8.0].define(version: 2025_08_31_213446) do
  # These are extensions that must be enabled in order to support this database
  enable_extension "pg_catalog.plpgsql"

  create_table "accounts", force: :cascade do |t|
    t.string "name"
    t.bigint "vertical_id", null: false
    t.string "email"
    t.string "phone"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["vertical_id"], name: "index_accounts_on_vertical_id"
  end

  create_table "appointments", force: :cascade do |t|
    t.bigint "account_id", null: false
    t.bigint "customer_id", null: false
    t.bigint "service_type_id", null: false
    t.bigint "staff_id", null: false
    t.datetime "scheduled_at"
    t.integer "duration_minutes"
    t.string "status"
    t.text "notes"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["account_id"], name: "index_appointments_on_account_id"
    t.index ["customer_id"], name: "index_appointments_on_customer_id"
    t.index ["service_type_id"], name: "index_appointments_on_service_type_id"
    t.index ["staff_id"], name: "index_appointments_on_staff_id"
  end

  create_table "customers", force: :cascade do |t|
    t.bigint "account_id", null: false
    t.string "first_name"
    t.string "last_name"
    t.string "email"
    t.string "phone"
    t.text "address"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["account_id"], name: "index_customers_on_account_id"
  end

  create_table "flipper_features", force: :cascade do |t|
    t.string "key", null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["key"], name: "index_flipper_features_on_key", unique: true
  end

  create_table "flipper_gates", force: :cascade do |t|
    t.string "feature_key", null: false
    t.string "key", null: false
    t.text "value"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["feature_key", "key", "value"], name: "index_flipper_gates_on_feature_key_and_key_and_value", unique: true
  end

  create_table "service_types", force: :cascade do |t|
    t.string "name"
    t.bigint "vertical_id", null: false
    t.integer "duration_minutes"
    t.boolean "requires_background_check"
    t.decimal "min_staff_ratio"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["vertical_id"], name: "index_service_types_on_vertical_id"
  end

  create_table "staffs", force: :cascade do |t|
    t.bigint "account_id", null: false
    t.string "first_name"
    t.string "last_name"
    t.string "email"
    t.string "phone"
    t.boolean "background_check_passed"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["account_id"], name: "index_staffs_on_account_id"
  end

  create_table "verticals", force: :cascade do |t|
    t.string "name"
    t.string "slug"
    t.text "description"
    t.boolean "active"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  add_foreign_key "accounts", "verticals"
  add_foreign_key "appointments", "accounts"
  add_foreign_key "appointments", "customers"
  add_foreign_key "appointments", "service_types"
  add_foreign_key "appointments", "staffs"
  add_foreign_key "customers", "accounts"
  add_foreign_key "service_types", "verticals"
  add_foreign_key "staffs", "accounts"
end
</file>

<file path="db/seeds.rb">
# This file should ensure the existence of records required to run the application in every environment (production,
# development, test). The code here should be idempotent so that it can be executed at any point in every environment.
# The data can then be loaded with the bin/rails db:seed command (or created alongside the database with db:setup).
#
# Example:
#
#   ["Action", "Comedy", "Drama", "Horror"].each do |genre_name|
#     MovieGenre.find_or_create_by!(name: genre_name)
#   end
</file>

<file path="public/robots.txt">
# See https://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file
</file>

<file path="spec/factories/accounts.rb">
FactoryBot.define do
  factory :account do
    name { "MyString" }
    vertical { nil }
    email { "MyString" }
    phone { "MyString" }
  end
end
</file>

<file path="spec/factories/appointments.rb">
FactoryBot.define do
  factory :appointment do
    account { nil }
    customer { nil }
    service_type { nil }
    staff { nil }
    scheduled_at { "2025-08-31 14:22:53" }
    duration_minutes { 1 }
    status { "MyString" }
    notes { "MyText" }
  end
end
</file>

<file path="spec/factories/customers.rb">
FactoryBot.define do
  factory :customer do
    account { nil }
    first_name { "MyString" }
    last_name { "MyString" }
    email { "MyString" }
    phone { "MyString" }
    address { "MyText" }
  end
end
</file>

<file path="spec/factories/service_types.rb">
FactoryBot.define do
  factory :service_type do
    name { "MyString" }
    vertical { nil }
    duration_minutes { 1 }
    requires_background_check { false }
    min_staff_ratio { "9.99" }
  end
end
</file>

<file path="spec/factories/staffs.rb">
FactoryBot.define do
  factory :staff do
    account { nil }
    first_name { "MyString" }
    last_name { "MyString" }
    email { "MyString" }
    phone { "MyString" }
    background_check_passed { false }
  end
end
</file>

<file path="spec/factories/verticals.rb">
FactoryBot.define do
  factory :vertical do
    name { "MyString" }
    slug { "MyString" }
    description { "MyText" }
    active { false }
  end
end
</file>

<file path="spec/models/account_spec.rb">
require 'rails_helper'

RSpec.describe Account, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/appointment_spec.rb">
require 'rails_helper'

RSpec.describe Appointment, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/customer_spec.rb">
require 'rails_helper'

RSpec.describe Customer, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/service_type_spec.rb">
require 'rails_helper'

RSpec.describe ServiceType, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/staff_spec.rb">
require 'rails_helper'

RSpec.describe Staff, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path="spec/models/vertical_spec.rb">
require 'rails_helper'

RSpec.describe Vertical, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
</file>

<file path=".dockerignore">
# See https://docs.docker.com/engine/reference/builder/#dockerignore-file for more about ignoring files.

# Ignore git directory.
/.git/
/.gitignore

# Ignore bundler config.
/.bundle

# Ignore all environment files.
/.env*

# Ignore all default key files.
/config/master.key
/config/credentials/*.key

# Ignore all logfiles and tempfiles.
/log/*
/tmp/*
!/log/.keep
!/tmp/.keep

# Ignore pidfiles, but keep the directory.
/tmp/pids/*
!/tmp/pids/.keep

# Ignore storage (uploaded files in development and any SQLite databases).
/storage/*
!/storage/.keep
/tmp/storage/*
!/tmp/storage/.keep

# Ignore CI service files.
/.github

# Ignore Kamal files.
/config/deploy*.yml
/.kamal

# Ignore development files
/.devcontainer

# Ignore Docker-related files
/.dockerignore
/Dockerfile*
</file>

<file path=".gitattributes">
# See https://git-scm.com/docs/gitattributes for more about git attribute files.

# Mark the database schema as having been generated.
db/schema.rb linguist-generated

# Mark any vendored files as having been vendored.
vendor/* linguist-vendored
config/credentials/*.yml.enc diff=rails_credentials
config/credentials.yml.enc diff=rails_credentials
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files for more about ignoring files.
#
# Temporary files generated by your text editor or operating system
# belong in git's global ignore instead:
# `$XDG_CONFIG_HOME/git/ignore` or `~/.config/git/ignore`

# Ignore bundler config.
/.bundle

# Ignore all environment files.
/.env*

# Ignore all logfiles and tempfiles.
/log/*
/tmp/*
!/log/.keep
!/tmp/.keep

# Ignore pidfiles, but keep the directory.
/tmp/pids/*
!/tmp/pids/
!/tmp/pids/.keep

# Ignore storage (uploaded files in development and any SQLite databases).
/storage/*
!/storage/.keep
/tmp/storage/*
!/tmp/storage/
!/tmp/storage/.keep

# Ignore master key for decrypting credentials and more.
/config/master.key
</file>

<file path=".rubocop.yml">
# Omakase Ruby styling for Rails
inherit_gem: { rubocop-rails-omakase: rubocop.yml }

# Overwrite or add rules to create your own house style
#
# # Use `[a, [b, c]]` not `[ a, [ b, c ] ]`
# Layout/SpaceInsideArrayLiteralBrackets:
#   Enabled: false
</file>

<file path=".ruby-version">
3.2.0
</file>

<file path="config.ru">
# This file is used by Rack-based servers to start the application.

require_relative "config/environment"

run Rails.application
Rails.application.load_server
</file>

<file path="Dockerfile">
# syntax=docker/dockerfile:1
# check=error=true

# This Dockerfile is designed for production, not development. Use with Kamal or build'n'run by hand:
# docker build -t carestack .
# docker run -d -p 80:80 -e RAILS_MASTER_KEY=<value from config/master.key> --name carestack carestack

# For a containerized dev environment, see Dev Containers: https://guides.rubyonrails.org/getting_started_with_devcontainer.html

# Make sure RUBY_VERSION matches the Ruby version in .ruby-version
ARG RUBY_VERSION=3.2.0
FROM docker.io/library/ruby:$RUBY_VERSION-slim AS base

# Rails app lives here
WORKDIR /rails

# Install base packages
RUN apt-get update -qq && \
    apt-get install --no-install-recommends -y curl libjemalloc2 libvips postgresql-client && \
    rm -rf /var/lib/apt/lists /var/cache/apt/archives

# Set production environment
ENV RAILS_ENV="production" \
    BUNDLE_DEPLOYMENT="1" \
    BUNDLE_PATH="/usr/local/bundle" \
    BUNDLE_WITHOUT="development"

# Throw-away build stage to reduce size of final image
FROM base AS build

# Install packages needed to build gems
RUN apt-get update -qq && \
    apt-get install --no-install-recommends -y build-essential git libpq-dev libyaml-dev pkg-config && \
    rm -rf /var/lib/apt/lists /var/cache/apt/archives

# Install application gems
COPY Gemfile Gemfile.lock ./
RUN bundle install && \
    rm -rf ~/.bundle/ "${BUNDLE_PATH}"/ruby/*/cache "${BUNDLE_PATH}"/ruby/*/bundler/gems/*/.git

# Copy application code
COPY . .




# Final stage for app image
FROM base

# Copy built artifacts: gems, application
COPY --from=build "${BUNDLE_PATH}" "${BUNDLE_PATH}"
COPY --from=build /rails /rails

# Run and own only the runtime files as a non-root user for security
RUN groupadd --system --gid 1000 rails && \
    useradd rails --uid 1000 --gid 1000 --create-home --shell /bin/bash && \
    chown -R rails:rails db log storage tmp
USER 1000:1000

# Entrypoint prepares the database.
ENTRYPOINT ["/rails/bin/docker-entrypoint"]

# Start server via Thruster by default, this can be overwritten at runtime
EXPOSE 80
CMD ["./bin/thrust", "./bin/rails", "server"]
</file>

<file path="Rakefile">
# Add your own tasks in files placed in lib/tasks ending in .rake,
# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.

require_relative "config/application"

Rails.application.load_tasks
</file>

<file path="README.md">
# README

This README would normally document whatever steps are necessary to get the
application up and running.

Things you may want to cover:

* Ruby version

* System dependencies

* Configuration

* Database creation

* Database initialization

* How to run the test suite

* Services (job queues, cache servers, search engines, etc.)

* Deployment instructions

* ...
</file>

<file path="config/application.rb">
require_relative "boot"

require "rails"
# Pick the frameworks you want:
require "active_model/railtie"
require "active_job/railtie"
require "active_record/railtie"
require "active_storage/engine"
require "action_controller/railtie"
require "action_mailer/railtie"
require "action_mailbox/engine"
require "action_text/engine"
require "action_view/railtie"
require "action_cable/engine"
# require "rails/test_unit/railtie"

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(*Rails.groups)

module Carestack
  class Application < Rails::Application
    config.active_record.query_log_tags_enabled = true
    config.active_record.query_log_tags = [
      # Rails query log tags:
      :application, :controller, :action, :job,
      # GraphQL-Ruby query log tags:
      current_graphql_operation: -> { GraphQL::Current.operation_name },
      current_graphql_field: -> { GraphQL::Current.field&.path },
      current_dataloader_source: -> { GraphQL::Current.dataloader_source_class },
    ]
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 8.0

    # Please, add to the `ignore` list any other `lib` subdirectories that do
    # not contain `.rb` files, or that should not be reloaded or eager loaded.
    # Common ones are `templates`, `generators`, or `middleware`, for example.
    config.autoload_lib(ignore: %w[assets tasks])

    # Configuration for the application, engines, and railties goes here.
    #
    # These settings can be overridden in specific environments using the files
    # in config/environments, which are processed later.
    #
    # config.time_zone = "Central Time (US & Canada)"
    # config.eager_load_paths << Rails.root.join("extras")

    # Only loads a smaller set of middleware suitable for API only apps.
    # Middleware like session, flash, cookies can be added back manually.
    # Skip views, helpers and assets when generating a new resource.
    config.api_only = true
  end
end
</file>

<file path="config/routes.rb">
Rails.application.routes.draw do
  post "/graphql", to: "graphql#execute"
  
  if Rails.env.development?
    mount GraphiQL::Rails::Engine, at: "/graphiql", graphql_path: "/graphql"
  end
  
  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html
  
  # Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500.
  # Can be used by load balancers and uptime monitors to verify that the app is live.
  get "up" => "rails/health#show", as: :rails_health_check
end
</file>

<file path="Gemfile">
source "https://rubygems.org"

ruby "3.2.0"

# Rails Core
gem "rails", "~> 8.0.0"
gem "bootsnap", require: false
gem "dotenv-rails", groups: %i[development test]

# Database & Persistence
gem "pg", "~> 1.1"
gem "ulid", "~> 1.2.0"
gem "discard", "~> 1.2"
gem "will_paginate", "~> 4.0"

# API & GraphQL
gem "graphql", "~> 2.0"
gem "jbuilder"

# Background Jobs
gem "sidekiq", "~> 7.0"
gem "redis", "> 5"

# Authentication & Authorization
gem "devise", "~> 4.9"
gem "jwt", "~> 2.7"

# Forms & Validation
gem "reform-rails"
gem "reform"

# File Uploads
gem "shrine", "~> 3.0"
gem "image_processing", "~> 1.8"

# Feature Flags
gem "flipper"
gem "flipper-active_record"
gem "flipper-ui"

# Payments (like ZenMaid)
gem "stripe", "~> 5.55"
gem "stripe_event", "~> 2.3"

# Utils & Helpers
gem "money-rails"
gem "chronic", "~> 0.10"
gem "sanitize"
gem "oj"

# Scheduling & Calendar
gem "icalendar", "~> 2.4"
gem "ice_cube"

# Decorators
gem "draper"

# Error Tracking
gem "rollbar"

group :development, :test do
  gem "pry-rails"
  gem "pry-byebug"
  gem "rspec-rails"
  gem "factory_bot_rails"
  gem "faker"
  gem "timecop"
end

group :development do
  gem "listen"
  gem "bullet"
  gem "graphiql-rails"
  gem "letter_opener"
  gem "annotate"
  gem "graphiql-rails"
end

group :test do
  gem "capybara"
  gem "database_cleaner-active_record"
  gem "rspec-sidekiq"
  gem "webmock"
  gem "simplecov", require: false
end

group :production do
  gem "puma", "~> 6.0"
  gem "rack-cors"
end
</file>

</files>
